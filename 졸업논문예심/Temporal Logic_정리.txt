1. Why temporal logic?
-잘 발달된 논리 기계는 시스템의 논리적 사양을 사용하는데 도움이 된다.

1.3 What is temporal logic?
-시간 논리는 고전 논리(classical logic)에 특히 시간과 관련된 연산자를 추가하여 확장하는 것이다.
-Modal logic은 temporal logic의 형식적 기초 중 일부를 제공하며 temporal logic에 사용되는 많은 기술은 해당 modal logic에서
파생된다.
-다음 순간을 의미하는 'O',(meaning in the next moment in time) 	//(next)
모든 미래 순간을 의미하는 '□',(meaning at every future moment)	//(always)
미래의 어떤 순간을 의미하는 '◇'(meaning at some future moment)와 같은 연산자가 포함되는 경우가 많다.	//(sometimes)
¬: 부정문 아니다, not
^: 그리고, 그러나, 그럼에도 불구하고(and)
v: 또는 (or)
->:만일 ~라면(if~then~)만약 A 이면 B이다.
<->: ~일 경우 그리고 그 경우에만 (if and only if) :: A if and only if B: 만약 A가 참이라면 B도 참이고 또한 만약 B가 참이라면 A도 참이다
⇔ : A와 B가 모두 참이거나 모두 거짓일 때 성립한다.(iff)==if and only if
⊢: x ⊢ y는 y가 x에서 증명가능하다는 뜻이다.
⊨: x ⊨ y는 x가 의미론적으로 y를 수반한다는 뜻이다.
∃: there exist, 어떤 ~가 존재하여
∀: for all, for any, for each, 모든 ~에 대해
◇+: O◇

-위 3가지 뿐만 아니라 추가 연산자를 사용하면 다음과 같은 공식을 구성할 수 있다.
-□(try_to_print	=>	◇¬try_to_print)
"우리가 문서를 인쇄하려고 할 때마다 미래의 어느 순간에는 인쇄를 시도하지 않을 것입니다."

-시간적 논리의 유연성을 통해 다음과 같은 공식을 제공할 수도 있다.
-□(try_to_print	=>	O(printed v try_to_print))
"문서를 인쇄하려고 할 때마다 다음 순간에 문서가 인쇄되거나 다시 인쇄를 시도합니다."

-□(printed	=>	O□¬try_to_print)
문서가 인쇄될 때마다 시스템은 인쇄를 시도하지 않습니다(다시는)"

-우리는 결국 문서 인쇄 시도를 언젠가 멈출 것임을 보여줄 수 있어야 한다.
◇□¬try_to_print 위의 공식에서 유추할 수 있다.

2.1 Intuition
-classical logic에서 공식은 고정된 단일 세계 또는 상태 내에서 평가된다.
"it is Monday" True or False 입니다.
-이러한 명제는 '^', '¬' 및 '=>'와 같은 구성(또는 접속사)를 사용하여 결합된다.
-따라서 classical propositional logic(고전적 명제 논리)는 정적 상황을 설명하는데 사용된다.
-논리에서 명령문의 의미는 기본(atomic) 명제(propositional)을 True or False로 매핑하여 모델링 할 수 있따.

-a|->T, b|->F, c|->T
위 명제 공식을 만족하는 특정 구조(model)이라고 한다.
-a^(b v c) 여기서 모델 b는 F, c는 T라고 명시한다. 이것은 b v c가 T 이고, a가 T라는 사실과 결함되어 atomic 명제에 대한 진리 값 
할당에 대해 전체적으로 a^(b v c)가 T임을 의미한다.

-a|->T, b|->T, c|->F
이와 같은 경우 M⊨a^(b v c)
즉, 모델 M이 a^(b v c) 공식을 만족한다.

-시간 논리를 사용할 때 공식 평가는 고정된 세계가 아니라 일련의 세계 내에서 발생합니다. 따라서 '월요일입니다'는 일부 세계에서는 
사실일 수 있지만 다른 세계에서는 그렇지 않을 수 있습니다. 그런 다음 접근성 관계를 사용하여 세계 사이를 탐색하고 이 관계를 
시간적 관계로 해석하여 특정 시간 모델을 특성화합니다. 따라서 우리가 한 세계에서 다른 세계로 이동할 때 제도는 우리가 시간을 통해 
이동한다는 것입니다.
-따라서 우리는 일련의 세계, 일련의 상태 또는 일련의 명제 모델의 관점에서 시간 모델의 기초를 동등하게 설명할 수 있습니다. 
시퀀스의 각 상태는 다른 순간을 모델링하는 것으로 간주됩니다. 따라서 이름 시간 논리.

-기존 연산자 집합은 다양한 시간 연산자로 확장된다.

-시간을 순간/상태/세계의 연속으로 보는 관점이 접근 방식의 핵심입니다. 
-PTL이라고 하는 이 논리에서 기본 시간 모델은 이산적이고 선형 순서가 자연수 N과 같은 동형(같은 모양)입니다. 

-그림에서 검은색 원은 고전 명제 상태(classical propositional state)를 나타내고, 화살표는 접근성 관계(accessibility relation)을 나타냅니다.
이 경우에는 다음 순간으로의 '단계(step)'를 나타낸다.
-또한 'start of time'으로 식별되는 state가 하나 있다.
-Example 2.1 월요일부터 시작하여 한 주의 요일을 고려하면 이산 시퀀스를 얻을 수 있습니다. (potentially cyclic nature (잠재적 순환 특성))

2.2 Syntatic aspects
-PTL에서는 classical propositional state 연산자와 마찬가지로 미래의 순간을 나타내는 시간 연산자를 사용합니다.
Οφ: φ는 다음 순간에 참입니다.
□φ: φ는 미래의 모든 순간에 참입니다.			//모든 가능한 세계에서 참이다(필연적으로 참이다, 증명할 수 있다.)
◇φ: φ는 어떤 미래(또는 현재) 순간에 참입니다.		//참인 세계가 존재한다.(개연적으로 참이다, 반증할 수 없다.)
φUψ: ψ가 참인 미래의 어떤 순간까지 φ는 계속 참입니다.
φWψ: ψ가 참이 되지 않는 한 φ는 계속 참입니다.
-위에서 알 수 있듯이 항상 초기 순간(처음 시작점)이 있음을 확인하면 이 시작 시간에만 적용 되는 '시작'연산자를 도입할 수도 있다.

Example 2.2
- "메시지가 수신자에게 전송되면 메시지가 결국 수신됩니다.":
Send_msg =>◇receive_msg		// msg가 전송되면 =>msg 수신은 어떤 미래(또는 현재) 순간에 참입니다.
-“'have_passport' 또는 'have_ticket'이 거짓이면 다음 순간에 'board_flight'도 거짓이 되는 경우가 항상 있습니다.
□((¬have_passport v ¬have_ticket) => Ο¬board_flight)	//()안의 상황이 미래의 모든 순간에 참이다.
((passport를 갖고 있는 것이 거짓이고 or ticket을 갖고 있는 것이 거짓이라면)=>다음순간에 board_flight가 거짓이다.)
- "태어나면 죽는 시점까지 살아 있는 것입니다." ('until' 연산자 U의 자세한 의미는 나중에 설명하겠습니다):
born =>living U dead	//태어나면=>죽는 것이 참인 미래의 어떤 순간 까지 살아있는 것은 계속 참 입니다.

2.2.1 Formal definition
-명제 접속사: 참(true), 거짓(false), ¬, V, ^, <=> 및 =>.
-시간 접속사: Ο , □, ◇, 시작(start), U 및 W.
-괄호는 일반적으로 모호성을 피하기 위해 사용

-PTL: Propositional Temporal Logic
-wff: well formed formula
-Timed Propositional Temporal Logic (TPTL)
-Linear Temporal Logic (LTL)
-PROP: propositional(명제)

Excercise 2.1	
(a) april v OUmay	// May가 참인 미래의 어떤 순간까지 다음 순간은 계속 참이거나 april 이다.	//참
(b) may v O((april W may))	//다음순간에(May가 참이 되지 않는 한 april은 계속 참 입니다.)참입니다.	//
(c) Ojuly ^ august(◇september)	//불가

Example 2.4
Monday	=> Otuesday	//월요일이라면 화요일은 다음 순간에 참입니다.
begin 	=> ◇finish	//시작이라면 끝은 어떤 미래(또는 현재) 순간에 참입니다. // 시작이라면 어떤 미래(또는 현재)순간에 끝은 참이다.
july	=> ◇(december ^ winter)	//7월이라면 (12월 그리고 겨울)은 어떤 미래(또는 현재)순간에 참 입니다.
sunset	=> O(night W dawn)	//sunset이라면 다음 순간 (dawn이 참이 되지 않는 한 night은 계속 참)이다.
born	=> ◇□old	//태어났다면 늙는것은 어떤 미래(또는 현재), 미래의 모든 순간에 참이다. (◇□: 필연적으로)
monday	=> sad U saturday	//월요일이라면 토요일이 참인 미래의 어떤 순간까지 슬픔은 계속 참입니다.

Excercise 2.2
(a) "다음 순간에는 'running'이 true가 될 것이고, 그 후 어느 시점에서 'terminated'가 true가 될 것입니다."
Οrunning =>◇terminated
(b) "다음 순간에 '핑크'가 항상 참이거나 '갈색'이 참인 미래의 순간이 있습니다."
◇(Οpink v brown)
(c) "두 번째 순간에 '뜨거운'이 사실이 될 것입니다."
OOhot

2.3 Semantics
-시간은 논리 진술의 진실을 수정하는 추가 매개변수가 됩니다. 
М = < S, R, π >	
-S는 시간의 순간 세트(접근 가능한 세계 또는 상태)		//유한한 상태들로 구성된 집합
-R은 시간적 접근성 관계(PTL의 경우 선형이고 이산적이며 유한한 과거를 갖는 시퀀스를 특성화함)
- π: S->P(PROP)는 각 순간/세계/상태를 일련의 명제(즉, 그 순간/세계/상태에서 참인 명제)에 매핑

-그러나 N(자연수)과 동형인 선형 이산 기저를 갖는 PTL의 경우 이 모델 구조는 다음과 같이 단순화됩니다.
M = <N, π>
-π: N->P(PROP)는 각 자연수(시간의 한 순간을 나타냄)를 그 순간에 참인 명제 세트에 매핑

-때때로 우리는 이 구조를 다음과 같이 더 단순화합니다.
M = <S0, S1, S2, …>
-각 Si는 i번째 순간에 충족된 명제의 집합입니다.
-그러나 일반적으로 M=<N, π> 다양성을 사용합니다.

-(M x N x WFF) -> B		B는 평소와 같이 {T,F}의 집합.	//B = Boolean, True or False
-따라서 '⊨'(x가 의미론적으로 y를 잘 수반한다) 함수는 시간 구조, 해당 구조의 특정 순간 및 잘 구성된 시간 공식을 T 또는 F에 매핑합니다
-<M, i>⊨φ	
-M=구조(structure), i=시간 지수(temporal index), φ=공식(formula)
-참(즉, T로 평가)은 φ가 모델 M 내의 시간적 지수 i에서 충족되는 경우에만 해당합니다. 
-이 경우 M은 순간적 시간 i에서 해석될 때 φ에 대한 모델이라고 부를 수 있습니다. 그리고 φ는 이 모델에서 만족됩니다.

-Semantic of propositions.: 기본(원자) 명제의 의미론부터 시작합니다.
<M, i> ⊨ p	iff	p∈π(i)		(for any p∈PROP)

-M = <N, π>를 기억하면 주어진 시간 구조 (π(i)를 통해) 명제 기호가 시간 i의 특정 순간에 충족되는지 여부를 확인하기 위해
명제 기호를 간단히 look up 할 수 있다.

Classical operators. classical operator의 의미는 다음과 같다. 
-<M, i> |= ¬φ		iff	it is not the case that <M, i> |= φ
<M, i> |= ¬φ	는  <M, i> |= φ가 아닌 경우에만
-<M, i> |= φ^ψ	iff	both <M, i> |= φ and <M, i> |=ψ
-<M, i> |= φVψ	iff	<M, i> |= φ or <M, i> |=ψ
-<M, i> |= φ=>ψ	iff	if <M, i> |= φ then <M, i> |=ψ

-<M, i> |= start	iff	(i = 0)
 
-O연산자는 다음 순간에 대한 제약 조건을 제공하고 접근성 관계를 사용하여 한단계 앞으로 내다봅니다.
<M, i> |=Oφ		iff	<M, i+1> |=φ

Example 2.5
시간 연산자 'O'가 있으면 다음 순간으로 이동할 때 현재 상황이 어떻게 변경되는지 지정할 수 있다.
(a)	(sad ^ ¬rich) => Osad	//만약 (슬픔 그리고 not 부자) 이면 다음 순간에도 슬프다
(b)	(x_equals_1 ^ added_3) =>O(x_equals_4)	//만약(x=1 그리고 +3)이면 다음 순간에 x=4이다.

-우리는 기본 시간 모델로 N을 사용하고 있지만 또 다른 인기 있는 선택은 시작이 구분되지만 길이는 유한한 선형 이산 시퀀스를 
사용하는 것입니다.
-이 경우 모델의 미래 특성을 고려하도록 시간 연산자의 의미를 수정해야 합니다. 
-예를 들어, 'next' 연산자는 시퀀스의 다음 순간이 있으면 검사하지만 그러한 'next' 순간이 없으면 일반적으로 기본적으로 true입니다. 

-'◇φ'의 의미는 시간 인덱스 'φ'가 참일 것인 것에 대한 약간의 불확정성을 포함합니다. 
-◇ 의미론에서 j≥I 또는 j>i를 취할지 여부에 대한 선택이 있음을 유의하십시오	// ◇는 현재순간을 포함할 것인지, 포함하지 않을것인지에 대한 내용을 선택할 수 있다.
<M, i> |= ◇φ (j≥i) 및 <M, j> |= φ인 j가 존재하는 경우 
-◇+: O◇		//다음순간 때때로
<M, i> |= ◇+φ j가 존재하는 경우 (j>i) 및 <M, j> |= φ

Example 2.6	
(a) (¬resigned ^ sad) =>◇famous		//(퇴직하지 않았고 슬프다면) famous는 어떤 미래(또는 현재)순간에 참입니다.
(b) sad =>◇happy				//슬프다면 어떤 미래(또는 현재)순간 행복한것은 참입니다.
(c) is_monday =>◇+is_friday			//월요일이라면 다음순간 때때로 금요일은 참입니다.

-따라서 '□'의 의미는 시간의 모든 미래 순간, 즉 모두 j≥i를 나타냅니다. 여기서 i는 현재 시간 인덱스입니다.
-<M, i> |= □φ		iff	for all j, if (j≥i), then <M, j> |=φ	//현재를 포함한다는 의미
-<M, i> |= □+φ	iff	for all j, if (j> i), then <M, j> |=φ	//현재를 포함하지 않는다는 의미

Example 2.7
(a)lottery_win =>□rich
(b)□¬(electricity ^ water)
(c)(greater_than_zero ^ increasing) =>□greater_than_zero

-□p=>□□p
-중요하게도, '□'는 '◇'의 쌍대이므로 PTL의 정리(종종 공리)는
□φ <=> ¬◇¬φ.
이것은 어떤 것이 항상 참이면 절대 거짓이 아니어야 하며 그 반대도 마찬가지라는 의미로 이해됩니다.

-'until' 연산자 'U'를 사용하면 전체 상태 시퀀스 내에서 유한 간격에 대한 동작을 설명할 수 있습니다.
-따라서 φUψ는 어떤 속성 'φ'가 다른 속성 'ψ'가 참이 되는 순간(발생이 보장됨)까지 지속되는 상황을 특성화합니다.
-<M, i> |= φUψ	iff	there exists j such that(j≥i) and <M, i> |= ψ and 
				for all k, if (i ≤ k < j), then <M, k> |= φ
<M, i> |= φUψ (j≥i) 및 <M, i> |= ψ 및
모든 k에 대해 (i ≤ k < j)이면 <M, k> |= φ
-여기에서 'ψ'가 발생하는 (관련) 순간(즉, 순간 'j')을 찾은 다음 지금과 j 사이의 모든 순간('K'로 표시)에서 φ가 참이어야 합니다.
-φUψ는 ◇ψ를 의미한다. 
-결과적으로 ψ가 미래에 언제 발생할지 확신할 수 없지만 그렇게 될 것이라고 확신합니다. 또한 우리는 지금부터 ψ가 발생할 때까지 
φ가 계속 참이어야 한다는 것을 알고 있습니다.

-'unless' 연산자인 'W'는 'until' 연산자와 매우 유사하지만 φWψ에서 ψ가 발생하는 것이 보장되지 않으므로 
영속 속성(persistent property)이 실제로 영원히 지속될 수 있습니다. 
-<M, i> |= φWψ	iff	either <M, i> |= φUψ		or 	<M, i> |= □φ

Excercise 2.4
φWψ(ψ가 참이 되지 않는 한 φ는 계속 참입니다.) <=>(φUψ(ψ가 참인 미래의 어떤 순간까지 φ는 계속 참입니다.) 또는 φ는 미래의 모든 순간에 참입니다.)
φUψ(ψ가 참인 미래의 어떤 순간까지 φ는 계속 참입니다.)<=>(□ψ v □φ)

2.3.1 Axiom systems
-정리(Theorm)는 형식 언어의 보편적 진리를 설명하는 반면, 공리 체계(또는 공리화)(axiomatic system)는 주어진 것에서 새로운 
보편적 진리(즉, 정리)를 생성하기 위한 규칙을 제공합니다.
-정리는 일반적으로 '├' 기호가 접두사로 붙는 공식으로 정의됩니다(예: '├ true_thing').
-├ □ (φ<=>ψ) => (□φ=>□ψ)
-예를 들어, “비가 올 때마다 쏟아진다면, 항상 비가 오면 반드시 쏟아진다”.
φ: 비, ψ:쏟아지다
-'ㅁ'이 '=>'보다 우선합니다.

-├(start ^ □φ)=> □Oφ
-예를 들어, "처음부터 하늘이 항상 분홍색이라면 앞으로 하늘을 조사할 때마다 하늘이 분홍색이 될 것입니다."

-├□¬φ<=>¬◇φ
-예를 들어, "항상 어두우면 때때로 밝지 않은 경우가 있습니다."

-├O(φ ^ ψ) <=> Oφ ^ Oψ
-예를 들어, "내일도 행복하고 내일도 배고프다면 내일도 행복하고 배고프게 될 것입니다."

-├(φU(ψ ^φUa))=>(φUa)
-예를 들어 “지금부터 알람이 울릴 때까지 자고 벨이 울릴 때까지 계속 자고 있다면 지금부터 벨이 울릴 때까지 자고 있는 것입니다.”
a: 벨, φ: 자다. ψ:알람
-├□(φ=>Oφ)=>(φ=>□φ)
-내가 기쁠 때면 다음 날도 분명 행복할 것이고, 지금 행복하다면 앞으로도 항상 행복할 것이다.

2.4 Reactive system properties
2.4.1 Safety properties
-이것들은 '나쁜 일이 일어나지 않을 것'이라는 요구 사항에 해당하는 시스템의 속성입니다.	//안전 속성
-이러한 속성은 '□¬...'형식의 시간 공식을 사용하여 설명됩니다	//어떤 순간에도 발생해서는 안되는 상황을 설명
□¬(reactor_temperature > 1000)
□¬(one_way ^O other_way)
□¬(OO(x=0) ^ OO (y=z/x))

2.4.2 Liveness properties
-특정 상황이 결국 발생해야 한다는 사실을 캡처합니다.	//활성 속성
-'좋은 일이 일어날 것입니다.'로 특징지을 수 있습니다. 
-이러한 속성은 일반적으로 '◇...'에 대한 시간 공식으로 설명됩니다.
◇rich
◇terminate
◇(x > 5)

-상상할 수 있듯이 대부분의 사양은 안전과 활성 속성을 결합합니다. 
-또한 '□'와 '◇'의 조합에는 다른 유형의 속성, 즉 공정성 속성과 관련된 특정 스타일이 있습니다. 

-Characterizing 'infinitely often'
-'□'와 '◇'연산자를 '□◇'로 조합하여 흔히 '무한하게 자주'를 나타낸다고 합니다. 

-□◇p의 참을 평가할 수 있습니다.
-<M, i> |= □◇p	iff	for all j, if(j≥i) , then <M, i> |= ◇p

-이제 <M, j> |= ◇p를 확장하면 다음을 얻습니다.
-<M, i> |= □◇p	iff	for all j, if(j≥i) , then there exists k such that(k≥j) and <M, k> |= p

-따라서 우리가 어느 시점에 있든 항상 p가 발생해야 하는 미래의 또 다른 지점이 될 것입니다. 타임라인에 무한한 수의 점이 있으므로 
p는 무한히 자주 발생해야 합니다.

2.4.4 Fairness properties
-'무한하게 자주' 개념이 있으면 '항상' 또는 '절대' 또는 '최소 한 번' 발생하지 않는 속성(예: 안전 및 활성 속성)을 특성화할 수 있습니다. 
-이제 속성이 때때로 발생한다는 아이디어를 포착할 수 있습니다. 이것은 무언가를 지속적으로 시도하려는 경우 특히 중요합니다. 
-이 경우 성공하지 못할지, 한 번, 매번 또는 무한히 자주 성공할지 알고 싶습니다. 	//빈도수를 알고 싶은것
-이러한 속성을 종종 공정성 속성이라고 합니다.

-□◇ attempt => □◇succeed	//강한 형태: 시도가 지속적으로 이루어지지 않더라도 무한한 수의 성공이 있을 것이다.(반드시 지속적으로 성공할 필요는 없음)
-무한하게 자주 시도하면 무한히 자주 성공합니다.

-□◇ attempt => ◇succeed
-우리가 무언가를 무한히 자주 시도한다면 적어도 한 번은 성공할 것입니다.

-□ attempt => □◇succeed
-우리가 계속해서 무언가를 시도한다면, 우리는 무한히 자주 성공할 것입니다.

-□attempt => ◇succeed		//약한 형태: 계속해서 시도해도 한 번만 성공할 수 있다는 보장이 있다.
-우리가 계속해서 무언가를 시도한다면, 우리는 적어도 한 번은 성공할 것입니다.

Example 2.12
-◇(∃x.printing(x))
-결국 일부 프로세스에서 인쇄가 허용됩니다.

-□¬(printing(a) ^ printing(b))
-프로세스 'a' 및 'b'에 대한 인쇄는 동시에 발생할 수 없습니다.

-∀y.□◇print_request(y) =>□◇printing(y)
-프로세스가 인쇄 요청을 무한히 자주 수행하면 해당 프로세스에 대한 인쇄가 무한히 자주 발생합니다.

N: Necessitation rule: if p is a theorem of any system involking N p->□p
K: Dsitribution axiom: if it is necessary that if p then q, then if necessarily p then necessarily q □(p=>q)=>(□p=>□q)
 
2.5 What is temporal logic?

-Answer 1: Temporal logic is a fragment of first-order logic	(시간 논리는 1차 논리의 단편입니다)
"PTL은 고전적인 1차 논리(산술 연산 포함)의 특정하고 결정 가능한(PSPACE-완전) 파편(조각)에 해당합니다."
-주로 이것은 고려되는 순간에 의해 매개 변수화된 고전적인 술어로 시간적 명제를 표현함으로써 달성된다.

i |=	start	is represented by 	i = 0
i |=	Op	is represented by 	p(i+1)
i |=	◇p	is represented by	∃j.(j≥i) ^ p(j)
i |=	□p	is represented by	∀j.(j≥i) =>p(j)

-Answer 2: Temporal logic characterizes simple induction	(시간 논리는 단순 귀납법을 특징 짓는다)
"PTL은 산술 유도의 간단한 형태를 포착합니다."
(귀납 공리: 수학적 귀납법을 이용하는 공리. 자연수 1에 대해 만족하고, 임의의 자연수 K에 대해 만족할 때 K+1에 대해서도 만족한다면 
모든 자연수에 대해서도 만족한다는 내용이다.)
-├□(φ=>Oφ)=>(φ=>□φ)

-이제 PTL을 i=0에 뿌리를 둔 유도 공리는 다음과 같이 공식화 될 수 있다.
[∀i.φ(i)=>φ(i+1)]=>[φ(0)=>∀j.φ(j)]
[φ(0) ^∀i.φ(i) => φ(i+1)] =>∀j.φ(j)

1. φ(0)을 표시하고
2. 임의의 i에 대해 이미 φ(i)를 알고 있으면 φ(i+1)를 설정할 수 있음을 보여줍니다.
그러면 φ(i)는 도메인의 모든 요소에 대해 참입니다.

-Answer 3: Temporal logic is a multi-modal logic (시간 논리는 다중 모드 논리입니다)
"PTL은 밀접하게 상호 작용하는 두 가지 양식 [1] 및 [*]을 포함하는 다중 모드 논리로 볼 수 있습니다."
Modal logic(양상 논리)는 다른 상태/세계/점에서 고유한 진리 값을 갖고 이러한 세계 사이를 탐색하기 위해 모달 연산자를 사용하는 
명제의 개념에 기반한 논리의 일반적인 형태를 설명하는 광범위한 연구 영역입니다. 
-일반적으로 모달 논리에는 '접근 가능한 모든 세계에서'를 의미하는 '[]' 연산자 및 '<>', '접근 가능한 세계에서'를 의미합니다.
-구문에서 '[1] 일반적으로 'O'로 표시되는 반면 '[*]'는 일반적으로 '□'로 표시됩니다.

├□(φ=>Oφ)=>(φ=>□φ)
├[*](φ=>[1]φ)=>(φ=>[*]φ)

-구체적으로, [*]는 [1]의 반사적 전이적 폐쇄를 나타냅니다.
 반사적: 자기에서 자기에게로 가는 집합이 존재할 때 '반사적'이라고 한다.
 전이적: A에서 B로 가는 관계가 있고, B에서 C로 가는 관계가 존재
동치관계
: 반사적, 전이적, 대칭적 관계를 모두 만족할 때 동치적이라고 한다.
- reflexive : A=A	반사적
- symmetric : (A=B) -> (B=A)	대칭적
- transitive : (A=B ∧ B=C) -> (A=C)	전이적

-Answer 4: Temporal logic is a logic describing sequences	(시간 논리는 시퀀스를 설명하는 논리입니다)
"PTL은 시퀀스에 대한 논리로 생각할 수 있습니다."

Si, S(i+1), ... |=	Op	if, and only if, S(i+1)...|=p
Si, S(i+1), ... |=	◇p	if, and only if, there exists a j≥i such that Sj, ...|=p
Si, S(i+1), ... |=	□p	if, and only if, for all j≥i then Sj,...|=p

-이런 식으로 PTL은 이러한 무한 시퀀스를 설명하는 논리로 볼 수 있습니다. 

-Answer 5: Temporal logic characterizes a class of ω-automata	(시간 논리는 ω-automata 클래스를 특성화합니다.)
"PTL은 무한 단어(ω-automata)에 대한 특정 유한 상태 오토마타의 구문 특성화로 볼 수 있습니다."
-섹션 2.7에서 볼 수 있듯이 PTL 모델은 유한 오토마타 클래스에서 허용되는 문자열로 볼 수 있습니다. 
-결과적으로 시간 공식을 사용하여 특정 오토마타를 설명할 수 있습니다. 

- □(p=>Oq)와 같은 공식은 automaton state 간의 가능한 전환에 대한 제약을 제공합니다.
- □◇r과 같은 수식은 automaton state 내에서 상태를 허용하는 데 제약을 줍니다. 즉, 무한히 자주 방문해야 하는 상태입니다. 
- s=>□t와 같은 공식은 automaton state 내의 global invariants을 설명합니다.

2.6 Normal form
-사용자 관점과 '기계화' 관점 모두에서 하나의 복잡한 공식을 여러 개의 간단한 공식으로 바꾸는 것이 종종 유용합니다. 
(공식은 책 참조)
-Rule이라고 하는 각 Ri는 스타일의 의미
-현재 행동에 대한 공식 => 현재와 미래 행동에 대한 공식.

-리터럴(literal)이란 소스 코드의 고정된 값을 대표하는 용어
-Separated Normal Form (SNF)	//분리된 정규형
-Ri의 규칙에는 시간 연산자 '□', 'U' 또는 'W'가 포함되어 있지 않음을 인식하는 것도 중요합니다. 나중에 보게 되겠지만, 
이들은 번역 과정에서 제거되어 동작을 시뮬레이션하는 SNF 규칙으로 대체됩니다.

-이 정규형은 시간이 시작될 때 참인 것(초기 규칙을 통해)(start), 
한 순간에서 다음 순간으로 이동할 때 반드시 참이어야 하는 것(단계 규칙을 통해)(O), 
미래의 순간에 어떤 제약이 존재하는지에(sometimes, ◇)  대한 간단하고 직관적인 설명을 제공합니다.
-바로 위의 설명은 연속적인 순간에 무슨 일이 일어나고 미래의 다른 (지정되지 않은) 순간에 어떤 일이 일어나야 하는지를 설명한다면 
직관적인 의미가 있다.

Example 2.14 
INITIAL:		start => losing v hopeful
STEP:		(losing ^ ¬hopeful) => Olosing
SOMETIME:	hopeful => ◇¬losing

-현재로서는 모든 PTL 공식이 (본질적으로) 동등한 동작, 특히 만족 가능성의 보존을 갖는 SNF 규칙 세트로 변환될 수 있다는 
중요한 속성에 주목합니다. 
-이것은 표현의 크기와 표현 내에서 사용되는 atomic 명제의 수에서 모두 증가하는 다항식 증가에 의해서만 달성된다.

2.7 Buchi automata and temporal logic
∈ Element
⊂ 부분집합
⊆ 부분집합(진부분집합, 오른쪽이 왼쪽에 완전히 포함된 집합)
-PTL에 대한 모델은 본질적으로 무한하고 이산적인 선형 시퀀스이며 식별된 시작 상태를 가지고 있습니다. 
-따라서 각 시간 공식은 해당 공식이 충족되는 일련의 모델에 해당합니다.
-모델 내의 각 특정 상태를 생각하면 각 상태가 유한한 크기임을 알 수 있습니다. 유한한 수의 명제와 그 명제에 대한 유한한 값 집합만 
있기 때문에 실제로 가능한 모든 상태의 유한 집합을 정의하고 (새) 고유한 기호를 사용하여 이러한 상태 각각을 나타낼 수 있습니다. 
이제 각 상태가 기호로 표시되면 모델은 이러한 기호의 시퀀스, 즉 문자열이 됩니다.
-필요한 오토마타는 종종 'ω-오토마타'라고 하는 무한 문자열에 대한 특정 형태의 오토마타입니다.

-유한 오토마타. 유한한 단어/문자열을 수용할 수 있는 유한 상태 자동 장치는 다음과 같이 정의할 수 있습니다.
FSA = <A, S, δ, I, F>
-A는 유한한 알파벳 심볼
-S는 유한한 상태의 집합
-δ⊆SxAxS 는 transition relation(전이 관계)
-I⊆S는 초기 상태 집합
-F⊂S는 마지막 상태 집합
-알파벳 A로 구성된 유한한 문자열을 허용합니다. 따라서 초기 상태(즉, I의 상태)에서 시작하여 시퀀스에서 연속적으로 기호를 읽을 수 있고
규정된 상태로 이동할 때마다 기호 시퀀스가 허용됩니다. δ에 의해 그리고 시퀀스의 마지막 기호를 읽은 후 최종 상태 중 하나로 끝납니다(즉, F의 상태).

Aside:
-두개의 유한한 상태의 automata
-FSA1 = <A1, S1, δ1, I1, F1>,	FSA2 = <A2, S2, δ2, I2, F2>
FSA1x2는 다음과 같이 정의된다.
FSA1x2 = <A1xA2, S1xS2, δ, I1xI2, F1xF2>
(<s1,s2>, a, <t1,t2>)∈δ if, and only if, (s1, a, t1)∈δ1, and (s2, a, t2)∈δ2 for a∈A1∩A2

-이제 PTL 내에서 볼 수 있는 무한 실행 시퀀스를 모델링하기 위해 무한 단어/문자열을 인식할 수 있는 유한 오토마타 형태가 필요합니다. 
ω-automata라고 하는 이 요구 사항에 맞는 많은 유형의 자동 장치가 있지만 우리가 사용할 다양한 유형은 Buchi Automata입니다. 
Buchi Automaton은 본질적으로 위와 같이 유한 상태 자동 장치입니다.

-BA = <A, S, δ, I, F>
-여기서 문자열 수용의 개념은 이제 무한 동작을 고려해야 하며 다음과 같이 정의됩니다. 모든 (무한) 실행에 대해 ρ라고 말하면 
이 실행은 다음과 같은 경우에만 BA에 의해 허용됩니다.
"F의 적어도 하나의 요소는 ρ를 따라 무한히 자주 나타납니다."

-특히, Buchi Automaton, Bφ는 공식 φ의 모든 가능한 모델을 나타내는 데 사용할 수 있습니다. PTL 공식 φ에서 이러한 automaton를 
생성하는 데 사용되는 다양한 메커니즘이 있습니다. 
- 우리는 재귀적(recursively)으로 φ를 분리하여 더 간단한 구성 요소에 대해 각각에 대한 automaton를 구성하고 이들을 
결합하여(일반적으로 합집합 및 곱 연산 사용, 나중에 참조) Bφ를 생성할 수 있습니다.
-PTL은 유한 모델 속성을 가지고 있기 때문에 φ에 대한 모델의 모든 가능한 명제 구성을 유한하게 설명할 수 있으므로 Bφ의 모든 가능한 
상태를 설명할 수 있습니다. I, 및 Bφ 내의 F; 또는
- φ를 SNF로 변환한 다음 SNF가 Bφ를 생성하기 위해 automaton 형식에 매우 가깝다는 사실을 사용합니다. 
– 초기 절은 본질적으로 초기 상태를 설명하고, 단계 절(step clause)은 전환 기능(transition function)의 한 형태를 캡처하고, 
(제약이 없는) 때때로 절은 수락 상태 집합(set of accepting state)을 설명합니다. .

2.7.1 Simple Buchi automata corresponding to temporal formulae
-시간식은 Buchi Automata를 사용하여 다음과 같이 설명할 수 있습니다. (여기에서 매우 유용한 리소스는 유용한 Buchi Automata의 
저장소를 제공하는 Buchi Store입니다.) 
-우리는 automaton이 우리가 볼 수 있는 명제 기호의 가능한 모든 조합으로 인식할 알파벳을 특성화하는 것으로 시작합니다. 따라서 
알파벳의 각 '문자(letter)'는 P(PROP)의 하위 집합입니다. 예를 들어, 우리의 자동 장치가 '{a, b, c}'를 인식하여 한 상태에서 다른 상태로 
이동할 수 있다는 것은 그 순간에 명제 a, b 및 c가 참이어야 함을 의미합니다
-따라서 형식적인 'Oa'는 automaton으로 표시될 수 있습니다(따라서 Oa를 충족하는 상태의 시퀀스는 이 automaton이 허용하는 시퀀스여야 함).

-여기에서 초기 상태 i에서 알파벳의 기호 조합으로 한 단계 앞으로 이동하여 상태 s0에 도달합니다. 
이제 'a'를 포함하는 명제 집합을 수락하면서 s1으로 이동할 수 있습니다. 
이러한 automaton는 무한 시퀀스를 허용하므로 s1에서 자신으로 다시 전환(레이블 없음)을 추가하여 제약 없이 무한 'tail'를 캡처해야 합니다(즉, 기호의 후행 시퀀스가 허용됨).

-여기서 몇 가지 주의할 점이 있습니다.
- 이것은 간단하고 결정적(즉, 이동할 상태에 대한 선택이 없음) automaton입니다.
- '수락' 상태, 즉 F의 상태는 이중 원으로 그래픽으로 표시됩니다(일반적으로 모든 상태가 수락하는 것은 아님).
- 이전에 상태/노드에 있는 '정보'(예: 어떤 명제가 참인지)를 사용하여 시간 공식의 모델을 표현했지만 위에서 볼 수 있듯이 이 정보는 
이제 상태 간의 전환 레이블에 캡처됩니다. 전환(transition)에 특정 레이블이 없으면 해당 전환에 모든 기호를 사용할 수 있습니다.
-우리는 종종 위와 같이 레이블(예: '{a}')로 while 세트를 제공하기보다 인식된 세트(예: 'a') 내의 요소를 작성합니다.

예제 2.15 위에 공식 '□a'를 그림으로 표현한 것이 있지만, 이에 대한 자동 표현은 <A, S, δ, I, F>입니다.
A = P({a,b,c})
S = {i,s0}
δ = {(i, a, s0), (s0, a, s0)}
I = {i}
F= {s0}

-공식 '◇a'는 수용 상태가 특히 중요해지는 자동 장치를 나타냅니다.
-여기서 계속해서 거짓(즉, i, s1, s1, s1, …)을 만드는 이 구조를 통해 무한 경로가 있음을 주목하십시오. 그러나 이 경로에서는 
수락 상태가 무한히 자주 발생하지 않으므로 자동 장치에서 경로를 수락하지 않습니다. 모든 허용 가능한 경로는 결국 s0을 방문해야 하며 
방문하는 즉시 s0을 영원히 순환해야 합니다.

Example 2.16 예를 들어 알파벳 {a, b, c}에 대한 위의 '◇a'의 자동 표현은 다음과 같습니다.
A = P({a,b,c})
S = {i,s0,s1}
δ = {(i, a, s0), (i, ¬a, s0), (s0,true,s0), (s1,¬a,s1), (s1,a,s0)}
I = {i}
F= {s0}

-위(때로는 나중에)에서 '¬a'를 레이블로 사용하여 표기법을 약간 남용합니다. 알파벳에는 그런 문자가 없습니다. 
우리는 이것을 '포함하지 않는 {a, b, c}의 하위 집합'의 약어로 사용합니다. 마찬가지로 '알파벳의 모든 문자'의 약어로 'true'를 사용합니다.

-마지막으로 공식 '□a v □b'는 다른 형태의 복잡한 동작을 나타냅니다.
-□a의 모델을 받아들이는 오토마타와 □b의 모델을 받아들이는 다른 오토마타가 있다면, 위의 구조는 본질적으로 두 오토마타의 합집합입니다. 

-위의 모든 오토마타에서 핵심적인 측면은 각각이 최소한 하나의 무한 시퀀스(F를 무한히 자주 방문)를 받아들여야 한다는 것입니다. 
이것은 우리를 시간 공식의 진실을 결정하는 메커니즘으로 이끕니다. 
 
φ is valid	iff	¬φ is unsatisfiable
	iff	B¬φ, the automaton accepting all models of ¬φ, is empty
	iff	B¬φ has no infinite accepting sequences
-따라서 φ의 유효성을 확인하기 위해 ¬φ의 가능한 모든 모델을 캡처하는 Buchi Automaton인 B¬φ를 구성할 수 있습니다. 
B¬φ에 무한 수락 시퀀스가 없으면 φ가 유효하다는 것을 압니다. 

2.7.2 Checking Buchi emptiness
-기본적으로 Buchi Automaton의 비어 있음을 확인하는 것은 자동 시스템 구조에서 다음 삭제를 각각 수행하는 주기적인 프로세스입니다.

-일치되지 않는 레이블이 있는 가장자리/전환 제거-우리는 아직 그러한 예를 많이 보지 못했지만 'a'와 '¬a'를 레이블로 제공하는 
가장자리/전환에 대한 레이블이 있다고 상상해 보십시오.
-가장자리/전환이 없는 노드/상태를 제거합니다. 이 노드/상태를 통해 무한 경로(모든 허용 경로가 무한함)가 올 수 없기 때문에 
여기에서 삭제가 허용됩니다. 그리고
- 터미널을 제거하고 노드/상태 집합을 허용하지 않습니다.











