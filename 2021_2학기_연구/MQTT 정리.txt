*A Survey on MQTT; A Protocol of Internet of Things*
-IoT에서 장치 간 통신은 푸시 또는 폴링 프로토콜을 통해 고려된다. 푸시 프로토콜은 가볍고 높은 생산성으로 인해 IoT 장치에 더 적합하다
-MQTT가 가장 널리 사용되는 XMPP, MQTT, AMQP와 같이 IoT에서 사용할 수 있는 많은 푸시 프로토콜이 있다.
-MQTT의 주요 특징은 가벼운 무게와 대역폭 효율성
-IoT에서 IoT 기기는 시스템을 관리하기 위해 다른 기기에 명령을 전달해야 하기 때문에 서로 다른 기기 간의 메시지 전송이 중요하다.[1]
-Push 프로토콜은 Polling 프로토콜에 비해 대역폭이 열악한 네트워크에서 구성되어 IoT 기기에 적합한 메시지 통신 프로토콜이다.
-MQTT는 저전력 기계에서 경량 프로토콜로 작동하도록 설계되었기 때문에 많은IoT 장치 및 인스턴트 메시지 전달 시스템의 일부로 활용
-MQTT는 긴 네트워크 지연과 낮은 대역폭 네트워크 조건에서 데이터를 정확하게 전송하도록 계획되었다.
-MQTT에서 통신을 이해 지정된 방식으로 제어 패킷 범위를 교환한다.

-Basic Concept of MQTT
-Publish/Subscribe; MQTT프로토콜에서 발행자는 일반적으로 발행/구독 모델로 간주되는 주제를 구독하는 사용자와 메시지를 발행합니다.
구독자는 자신과 관련된 특정 주제를 구독하고 모든 메시지를 수신하면 해당 주제에 게시된다. 반면에 클라이언트는 모든 구독자가 해당
주제의 메시지에 액세스 할 수 있도록 하는 방식으로 주제에 메시지를 게시할 수 있다.
-Topics and Subscriptions; MQTT에서 게시자는 메시지 제목으로 간주될 수 있는 주제에 메시지를 게시합니다. 따라서 구독자는 특정 메시지를
받기 위해 주제를 구독한다. 주제의 구독은 특정 주제로 수집되는 데이터를 제한하며 명시적일 수 있다. 주제에는 다양한 관련 주제에 대한
데이터를 얻기 위한 두 개의 와일드 카드 수준이 포함되어 있다.
-Quality of Service levels; 이 프로토콜은 데이터 배포의 보증과 관련하여 메시지의 두 당사자 간의 거래인 서비스 품질 수준을 설명
-QoS0(최대 한번);이러한 서비스 품질 수준에서 메시지는 최대 한번만 전송되며 메시지 전달을 보장하지 않는다.
-QoS1(최소 한번);이러한 서비스 품질 수준에서는 데이터가 한번 이상 전송되며 중복 플래그 값을 1로 설정하여 메시지를 두번 이상 전달
할 수 있다.
-QoS2(딱 한번);이러한 서비스 품질 수준에서 메시지는 4-way 핸드 셰이킹을 사용하여 정확히 한 번 전송한다.
-QoS 레벨의 선택은 시스템이 일정한 데이터 전달을 필요로 하는 경우, 시간 지연이 있더라도 데이터 전송을 위해 QoS2를 적용하는 것과 
같이 시스템에 따라 다르다.
-Retained messages;MQTT에서 메시지는 현재 모든 클라이언트에 배포한 후 브로커에 보관된다. 동일한 주제에 대해 다른 회원가입 시
해당 주제의 보유 메시지를 신규 고객에게 전달한다.
-Clean sessions and reliable connection; 가입자가 브로커와 연결하는 시점에서 클린 세션 연결은 값이 false인 경우 영구적인 것으로 
간주된다. 이 작업에서 가장 높은 QoS 할당을 전달하는 연속 메시지는 연결이 재개될 때 전달을 위해 예약된다. 이 플래그의 사용은 선택
사항 이다.
-Wills; 클라이언트는 예상치 못한 분리의 경우 특정 주제에 배포되어야 하는 메시지가 포함되어 있음을 브로커에 알릴 수 있다. 이러한 의지는
센서가 시스템과의 연결이 끊어진 것처럼 관리자가 즉시 알림을 보내는 보안 또는 경보 설정과 같은 시스템에서 특히 중요하다.

-일반적인 MQTT아키텍처는 두 가지 주요 구성 요소로 나눌 수 있다.
-Client; 클라이언트는 게시자 또는 구독자가 될 수 있으며 항상 서버(브로커)에 대한 네트워크 연결을 설정한다.
->관심있는 사용자를 위한 메시지를 게시한다.
->메시지 수신을 위해 관심있는 주제룰 구독한다.
->구독을 취소하면 구독중인 주제에서 추출할 수 있다.
->브로커에서 분리한다.
-Broker; 브로커는 정보 배포를 제어하고 게시자로부터 모든 메시지를 수신하고 필터링하고 관심있는 사람을 결정한 다음 구독한 모든
클라이언트에게 메시지를 보내는 일을 주로 담당한다.
->클라이언트 요청을 수락한다.
->사용자가 게시한 메시지를 수신한다.
->사용자의 구독 및 구독 취소와 같은 다양한 요청을 처리한다.
->게시자로부터 메시지를 수신한 후 관심있는 사용자에게 보낸다.

-처리 용량이 제한된 임베디드 장치 또는 불안정한 네트워크에 연결된 장치와 같은 제한된 환경은 MQTT프로토콜에 가장 적합하다.
-Health Care; 이 조직은 IBM과 협력하여 피해자가 기본 시스템에 가까이 있는 모든 지점에서 진단을 수집하는 가정 관찰 기계에
MQTT고객을 삽입하는 답변을 만들었다. 그런 다음 웹을 통해 표시 정보를 주 도메인으로 전달한다. 이 정보는 측정값을 분석하고 
피해자가 문제를 겪을 수 있다는 힌트가 있는 경우 의료 팀을 인식하는 어플리케이션에 제공된다. 
-Energy and Utilities; 서비스 조직은 일반적으로 확장된 금액을 영원히 지출할 수 없는 고객 루트의 전기에 대한 관심이 높아지면서 
전력 공급 비용 증가에 직면했다. 그래서 고객이 감당할 수 없는 발전 요금을 신속히 집행하기 보다 먼저 고객 아파트에 스마트 계량기를
설치하여 확실한 전력 흡수 장치의 적용을 원격으로 관리함을써 일반 전력 수요 감소에 대한 해답을 찾았다. 어떤 경우든, 조직은
전달된 정보의 양에 따라 급여를 받기 때문에 접근 가능한 정보 네트워크의 활용을 최소화 할 것으로 예상된다.
VPP(가상 발전소)의 제작은 조직의 생산 출처와 고객 사이에 있는 배치였다. 스마트 미터는 가정용 아파트에서 사용되는 다양한 장치에 대한
사용정보를 수집한다. 이때 아파트 게이트웨이는 MQTT를 진행한 고객과 함꼐 검사하여 정상 간격으로 VPP에 이용정보를 주변 휴대폰 수배선에
배포한다.
-Social Networking; 장거리 대인 커뮤니케이션 조직은 정보를 전송하는 동안 지연 문제를 경험했다. 조직이 데이터를 전달하기 위해 사용한
전력은 안정적이면서도 시간이 많이 소요되었으며, 유사한 메커니즘을 계속 사용하면 솔루션이 제한되었다. 더 많은 배터리 전력을 흡수하지
못하는 서버 간의 지속적인 연결을 위한 또 다른 구조가 필요했으며 이는 조직의 시민 커뮤니케이션 사이트의 클라이언트에게 기본이다.
MQTT 연결을 유지하고 MQTT의 대화 채널(채팅 파이프라인)을 통해 데이터를 전송함으로써 조직은 몇분이 아닌 1x10^5마이크로 초의 
속도로 데이터 배포를 달성할 수 있다.

-MQTT브로커는 각 MQTT배열의 핵심이다. 어플리케이션 또는 물리적 장치와 enterprise 시스템간의 연결 링크를 제공한다.
-브로커는 가입, 결정된 세션, 부재중 메시지 및 인증 및 권한 부여를 포함한 일반 보안을 담당한다.

-MQTT는 IoT 자산이 제한된 장치기 때문에 IoT에 가장 널리 사용되는 통신 프로토콜이다.그러나 해결해야 하는 몇가지 제한사항이 존재
-Messge Expiry; 현재 MQTT에는 메시지 만료가 없으므로 브로커에 메시지를 넣은 다음 수집하는 것을 잊어 버리거나 아무도 데리러 오지
않는 경우에는 메시지가 영원히 유지된다. 결과적으로 브로커에 메시지가 과부하되어 전반적인 성능이 저하된다.
-Security; MQTT프로토콜은 인증을 위한 사용자 이름과 비밀번호를 제공하고 다양한 브로커 구현은 그 위에 다른 메커니즘을 추가한다
따라서 MQTT의 보안은 사용 사례와 브로커 선택에 따라 달라진다. 대부분 브로커는 TLS기반 보안을 제공하지만 TLS는 성능, 특히
핸드 셰이크 중 CPU사용량에 큰 영향을 미친다.
-Ordering; IoT 환경에서 신뢰할 수 있는 데이터 전송 조직의 주요 과제는 메시지 순서 지정 및 전송 중 손실된 메시지 재전송이다. 
MQTT는 메시지 전달을 보장하지만, MQTT에서 메시지 순서를 유지하는 것은 어려운 작업이다.
-Priority; MQTT는 메시지 우선 순위라는 기능을 지원하지 않는다. 시스템에 더 중요한 데이터가 있는 경우 모든 가입자가 즉시 사용할 수 
있어야 한다. 예를 들어 화재 경보 시스템에서 수집한 온도 데이터는 압력 센서 데이터보다 더 중요하므로 모든 수신기에서 먼저 사용할 수
있어야 한다. 따라서 메시지의 우선 순위를 위해서는 순서대로 데이터를 보내는 것이 필요하다.

*MQTT-S-A Publish/Subscribe Protocol For WSN*
-데이터 중심 통신의 한 형태는 발행/구독 메시징 시스템이다. 다른 데이터 중심 변형과 비교하여 게시/구독 시스템은 분산 컴퓨팅에서 
일반적이며 널리 보급되어 있다. 따라서 구독/게시 시스템을 WSN을 확장하면 센서 응용프로그램과 다른 분산 응용 프로그램의 통합이
간소화된다.
-MQTT-S는 저가형 및 배터리로 작동되는 센서/액추에이터 장치에서 실행되고 Zigbee 기반 네트워크와 같은 대역폭이 제한된 WSN에서
작동할 수 있도록 설계되었다.
-그림1은 게이트웨이가 여러 WSN을 기존 네트워크에 연결하는데 사용되는 통합 네트워크의 일반적인 구조를 보여줍니다.
-WSN내에서 일반적으로 제한된 양의 저장 및 처리 기능을 갖춘 배터리로 작동되는 다수의 센서/액추에이터(SA)장치가 환경에 대한 정보를
수집하고 어플리케이션으로의 추가 전송을 위해 게이트웨이로 보냅니다. 액추에이터가 없는 네트워크의 경우에도 정보는 반대 방향으로 흐릅니다
(예; 센서 관리 및 구성, 소프트웨어 업데이트)
-무선 SA장치와의 상호작요이 필요한 응용 프로그램은 많은 노드의 주소를 관리하고 유지해야 한다. 대부분의 경우 정보를 전달하는 장치의
주소나 ID를 알 필요가 없다. 그들은 데이터의 내용에 더 관심이 있다. 예; 자산 추적 어플리케이션은 이 정보를 전달하는 GPS 수신기의
네트워크 주소보다 특정 자산의 현재 지리적 위치에 더 관심이 있다. 또한 여러 응용 프로그램에서 동일한 센서 데이터에 관심을 가질 수 있지만
목적은 다를 수 있다.
-정보가 네트워크 주소를 기반으로 하지 않고 컨텐츠 및 관심사의 함수로 소비자에게 전달되는 데이터 중심 통신 접근 방식을 사용하여
극복할 수 있다.
-발행/구독 메시징 시스템은 데이터 중심 통신의 잘 알려진 예이며 주로 동적 응용 프로그램 토폴로지의 확장성과 지원으로 인해 enterprise
네트워크에서 널리 사용된다.
-이러한 기능은 새로운 데이터 소스/소비자를 추가하거나 기존 모듈을 쉽게 교체할 수 있도록 다양한 통신 구성 요소를 서로 분리함으로써
달성된다.
-MQTT-S는 MQTT의 확장판으로 특히 저 비용 및 저전력 SA장치에서 작동하고 Zigbee 또는 TinyOS 기반 네트워크와 같이 대역폭이
제한된 WSN에서 실행되도록 설계되었다.
-발행/구독 통신 모델의 원리는 특정 정보를 소비하는데 관심이 있는 구성 요소가 관심을 등록한다는 것이다.이 관심을 동록하는 과정을 
구독이라고 하며 따라서 이해관계인을 구독자라고 한다. 
-특정 정보를 생성하려는 구성 요소는 정보를 게시한다. 그래서 게시자라고 한다. 
-게시자에서 구독자로 데이터를 가져오는 것을 보장하는 엔터티가 브로커이다. 브로커는 구독을 조정하고 구독자는 일반적으로 구독을
위해 명시적으로 브로커에게 연락해야한다.(엔터티; 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것을 설명)
-Pub/Sub 시스템에는 주제 기반, 유형 기반 및 컨텐츠 기반의 세가지 주요 유형이 있다.
-주제 기반 시스템에서 주제 목록은 일반적으로 예; 응용프로그램의 설계 단계에서 미리 알려진다. 구독 및 출판은 지정된 주제 세트에서만 
만들 수 있다. 
-유형 기반 시스템에서 가입자는 관심 있는 데이터 유형(예; 온도 데이터)를 명시한다. 유형 기반 시스템인 일반적이지 않다.
-컨텐츠 기반 시스템은 가장 다재다능한 시스템이다. 구독자는 수신하려는 메시지의 내용을 설명한다. 이러한 구독은 온도가 특정 임계값
미만이고 표시등이 켜져있는 온도 및 조명 판독값을 모두 포함하는 모든 메시지에 대한 것이다.
-컨텐츠 기반 메시징의 한 형태는 Tiny DB이다. 사용자는 사용자가 관심 있는 데이터를 설명하는 SQL과 같은 쿼리를 실행한다.
Tiby DB는 네트워크 내부의 데이터 집계도 허용한다. 하지만 Tiny DB는 범용 통신 플랫폼이 아니라 센서에 대한 쿼리 시스템이다. 
범용 컨텐츠 기반 발행/구독 시스템을 식별하기 위해 데이터에 메타 데이터를 추가해야 한다. 하지만 우리가 목표로 하는 매우 제한된
플랫폼에 대해 너무 높은 오버헤드를 초래한다고 믿는다.
-주제 기반 Pub/Sub 시스템의 통신 모델은 그림 2와 같다. 구독자는 표시된 주제에 대한 관심을 브로커에게 알리기 위해 sub(topic)메시지를
보내고 게시자는 pub(topic, data)메시지를 보낸다. 관련 주제와 함께 게시할 데이터가 포함되어 있다. 게시자의 주제와 구독자의 주제가 
일치하는 경우 브로커는 pub(topic, data)메시지를 구독자에게 전송한다. 주제가 이러한 구독자의 주제와 일치하는 경우 단일 메시지가
여러 구독자에게 배포될 수 있다.
-그림 3은 pub/sub 시스템이 통신 미들웨어로 사용될때 그림 1과 동일한 통합 네트워크의 결과 아키텍처를 보여준다. 기존 네트워크에 
브로커가 도입되고 다른 모든 구성 요소가 브로커에 연결되어 브로커의 pub/sub 서비스를 사용하여 서로 통신한다. 게이트웨이의 주요 기능은
SA 장치에 브로커에 대한 액세스 권한을 제공하는 것이다. 브로커는 대역폭 및 기능 면에서 더 높은 성능으로 인해 기존 네트워크에 위치한다.
-응용 프로그램 또는 SA 장치는 구독자와 게시자 모두일 수 있다. 구독자와 게시자는 동일한 장치에 있더라도 브로커에 의해 서로 분리된다.
예; 온도 센서는 여러가지 이유로 여러 어플리케이션에서 모니터링 해야 할 수 있다. 
-데이터를 사용할 수 있을 때 센서는 적절한 주제를 추가하고 이를 브로커에 게시한다. 그런 다음 브로커는 해당 주제를 구독한 어플리케이션에
게시된 데이터를 배포한다. 일치하는 주제로 함께 결합된 게시자 및 구독자 집합은 구독자 또는 게시자가 이를 인식하지 못한 상태에서 
시간이 지남에 따라 동적으로 변경될 수 있다. 이것은 장치가 실패할 수 있고 실패한 노드를 교체하거나 언제든지 네트워크를 확장하기 위해
새 장치를 추가할 수 있다.
-응용프로그램은 실패 및 변경 사항을 인식할 필요가 없다. 그들은 새로운 장치가 작동하기 시작할 때 데이터를 수신한다. SA 게시자 노드에도
동일하게 적용된다. 즉, 어떤 응용 프로그램이 자신의 데이터에 관심이 있는지 알 필요가 없다. 그들은 단지 그들의 데이터를 브로커에게 보내고,
브로커는 어플리케이션에 대한 데이터 배포를 처리할 것이다.
-응용프로그램 개발자의 경우 pub/sub 시스템은 기본 네트워크의 복잡성을 숨기고 응용프로그램 자체의 디자인에 집중할 수 있도록 한다.
특정 SA 장치의 데이터를 수신하려면 SA 장치가 데이터를 게시할 때 사용하는 주제만 알아야 합니다. 마찬가지로 SA 장치에 제어 정보를 
보내려면 실제 네트워크 주소가 아니라 SA 장치가 구독한 주제만 알면 된다. SA 장치가 다른 WSN으로 이동하더라도(예; 네트워크 정체로 인해)
SA가 여전히 발행 및 구독에 대한 동일한 주제를 사용하는 한 어플리케이션 및 게이트웨이를 변경할 필요가 없다. 또한 이러한 주제는
네트워크나 브로커가 아닌 어플리케이션 개발자 자신이 정의합니다.
-기업 네트워크가 이미 pub/sub 시스템을 통신 미들웨어로 사용하는 경우 pub/sub 프로토콜을 WSN으로 확장하면 두 네트워크의 상호
연결이 크게 단순화 된다. 기존 브로커 인프라는 SA 장치와 상호작용하고 관리하는데 사용할 수 있다. SA에서 수집한 현장 데이터는 다른 
기업 정보와 마찬가지로 모든 어플리케이션에서 원활하게 사용할 수 있으며, 같은 방식으로 SA 노드의 제어 및 관리도 기업 네트워크에 있는
모든 어플리케이션에서 수행할 수 있다.

-Publish/Subscribe Protocols for WSNs
-GSN(Gloabl Sensor Network)는 WSN을 블랙박스로 간주한다. WSN이 백본 네트워크에 연결되는 위치 또는 방법에 관계 없이 WSN을
쿼리하는 통합된 방법을 제공한다.
-MQTT-S는 끝점 세부 정보를 숨기는 것을 목표로 한다는 점이 다르다. 백본 네트워크 또는 WSN내부에서 실행되는 어플리케이션은
데이터가 WSN 또는 백본 네트워크의 장치에서 오는지 알지 못한다. 다른 WSN의 장치는 상호 통신할 수 있다. MQTT-S를 사용하면
WSN에서 데이터를 수집할 수 있을 뿐만 아니라 WSN 내부의 장치로 데이터를 보낼 수도 있다.
-Mires는 WSN을 위한 pub/sub 아키텍처이다. 기본적으로 센서는 사용자가 특정 센서 판독값을 구독한 경우에만 판독값을 게시한다.
메시지는 클러스터 헤드에서 집계될 수 있다. 구독은 싱크 노드(일반적으로 PC에 직접 연결됨)에서 발행된 다음 모든 발행물을 수신한다.
-DV/DRP는 WSN을 위한 또 다른 pub/sub 아키텍처이다. 구독은 원하는 메시지의 내용에 따라라 이루어진다. 구독이 네트워크에 넘쳐난다.
중간 노드는 구독을 집계한다. 그들은 이 출판물에 관심이 있는 경우에만 출판물을 전달한다. 임의의 데이터 패킷에 구독을 일치 시키는 것이
복잡하기 때문에 우리가 대상으로 하는 장치에서 이 프로토콜을 구현하기 어려울 것이다.

-MQTT
-MQTT는 원격 측정 어플리케이션에 사용되는 제한된 장치를 위해 설계된 개방형 pub/sub 프로토콜이다. 그러나 SA장치의 경우는 고려하지 
않는다.
-MQTT는 클라이언트 측(즉, SA측)에서의 구현이 매우 간단하도록 설계되어 있다. 모든 시스템 복잡성은 브로커 측에 있다. MQTT는 라우팅
또는 네트워킹 기술을 지정하지 않는다. 기본 네트워크가 순차 전달(예; TCP/IP)과 함께 지점간, 세션 지향, 자동 분할 데이터 전송 서비스를
제공하고 메시지 교환을 위해 이 서비스를 사용한다고 가정한다.
-MQTT는 문자열을 사용하여 계층적 주제를 지원하는 주제 기반 pub/sub프로토콜이다. 예; F2층, 방R248에 위치한 온도 센서는 계층적 주제
wsn/sensor/F2/R248/temperature를 사용하여 데이터를 게시할 수 있다. 슬래시 문자는 주제의 각 부분을 구분하는데 사용된다. 이후 와일드
카드 문자를 사용하여 주제의 모든 부분을 대체할 수 있다. 예; wsn/sensor/F2/+/temperature문자열을 사용하여 F2층의 모든 온도 센서에서
생성된 데이터를 구독할 수 있다.
-MQTT는 기본적인 종단 간 서비스 품질(QoS)를 지원한다. QoS0; 가장 간단한 것으로 메시지가 대상에 한 번만 배달되거나 전혀 배달되지 
않는 최선의 배달 서비스를 제공한다. 재전송 또는 승인이 정의되어 있지 않다. QoS1; 메시지는 수신자가 승인할 때까지 재전송된다. 결과적으로
QoS1 메시지는 확실히 도착하지만 재전송으로 인해 목적지에 여러번 도착할 수 있다. QoS2; 메시지 수신 뿐 아니라 수신 엔티티에 한 번만
전달되도록한다. 발행 및 구독에 대한 적절한 QoS 레벨을 선택하는 것은 어플리케이션에 달려있다.
-MQTT는 브로커와 발행물 및 구독을 겨환하기 전에 클라이언트가 브로커와의 연결을 설정해야한다는 점에서 연결 지향 프로토콜이다. 이를
이해 "CONECT"메시지가 정의된다. 다른 연결 매개변수 중에서 브로커가 연결된 클라이언트를 식별할 수 있도록 하는 클라이언트 ID가 포함
되어 있다. 이 클라이언트 ID는 예; 네트워크 오류 후 클라이언트가 다시 연결할 때 QoS수준1 및 2 게시가 올바르게 전달되도록 하기 위해
브로커에서 사용된다. 브로커는 클라이언트로부터 수신된 두 메시지 사이에 경과할 수 있는 최대 시간 간격을 정의하는 "연결 유지" 타이머에
의해 클라이언트/연결의 활성 상태를 감독한다. 이 시간 간격 동안 클라이언트가 전송할 데이터 관련 메시지가 없으면 브로커에 의해 승인된 
PING 메시지를 브로커에게 보낸다. 따라서 연결 유지 타이머를 사용하면 브로커가 클라이언트 또는 네트워크 링크의 오류를 감지할 수 있다.
-MQTT기능은 'WILL"개념을 지원한다. 연결시 클라이언트는 브로커에게 "WILL"주제와 함께 "WILL메시지를 저장하도록 요청할 수 있다.
브로커는 클라이언트와의 연결이 비 정상적으로 끊긴 경우에만 이 "WILL" 출판물을 가입자에게 보낸다. 응용프로그램은 이 기능을 사용하여
장치 및 링크의 오류를 감지할 수 있다.

-MQTT-S
-As close as possible to MQTT; 이를 통해 SA 장치를 MQTT브로커에 원활하게 연결할 수 있으므로 WSN을 기존 통신 인프라와 원활하게
통합할 수 있다. 이것은 또한 게이트웨이의 매우 간단하고 무손실 구현을 가능하게 한다. 결과적으로 MQTT-S는 MQTT기능 뿐만 아니라
MQTT에 의해 정의된 거의 모든 메시지 흐름 및 컨텐츠를 지원한다.
-Optimized for tiny SA device; 프로토콜은 처리 및 저장이 제한된 저비용 배터리 작동 장치에 대해 구현될 수 있는 방식으로 설계 되었다.
복잡성이 필요할 때마다 게이트웨이/브로커 측에 상주한다. SA 장치에서 실행되는 클라이언트는 가능한한 단순하게 유지된다.
-Consideration of wireless network constraints such as high link failure rates, low bandwith, and short message payload
높은 링크 실패율, 낮은 대역폭 및 단문 메시지 페이로드와 같은 무선 네트워크 제약 고려); 일반적으로 무선 라디오 링크는 페이딩 및
간섭 장애에 대한 민감성으로 인해 유선 링크보다 실패율이 높다. 실제로 무료 채널 평가 및 재전송으로 인해 대역폭이 후러씬 낮다.
링크 장애 또는 네트워크 정체로 인해 인프라에서 SA 연결이 끊어지는 위험을 줄이기 위한 절차를 정의해야 한다. 또한 전송 오류를 방지하기 위해
무선 네트워크는 유선 네트워크보다 패킷 길이가 훨씬 짧다. 즉, MQTT-S 메시지는 64바이트 보다 짧아야 한다. 사람이 읽을 수 있는 데이터 형식이
지원 되는 경우는 거의 없다. MQTT-S가 이러한 문제에 대처하는 방법은 다음과 같다.
-Network independet; MQTT-S는 다음 두 가지 서비스를 제공하는 모든 네트워크에서 실행되도록 설계되었다.
-Point to point data transfer service; 네트워크 주소를 기반으로 하는 두 지점 간의 메시지 전송을 허용하는 데이터 그램 서비스. 관련된
두 지점은 서로 여러 홉 떨어져 있을 수 있다.
-One-hop broadcast data transfer service; 원칙적으로 모든 무선 네트워크에서 지원된다. 노드가 보낸 메시지는 전송 범위 내의 모든 
노드에서 수신할 수 있다.
-MQTT와 달리 MQTT-S는 연결지향서비스를 가정하지 않으며 메시지 분할이나 해당 세그먼트의 순서 전달에 의존하지 않는다.

-MQTT-S Architecture
-구성요서는 MQTT-S 클라이언트와 MQTT-S 게이트웨이(GW) 두가지 유형이 있다. MQTT-S 클라이언트는 WSN측에 있으며 SA장치가 
기존 네트워크에 있는 MQTT 브로커의 게시/구독 서비스에 액세스 할 수 있도록 한다. MQTT-S 프로토콜을 사용하여 게이트웨이에 
연결하고 게이트웨이는 브로커에 연결한다. 게이트웨이 주요 기능은 MQTT와 MQTT-S프로토콜 사이를 변환하는 것이다. MQTT-S 게이트웨이는
브로커와 통합되거나 통합되지 않을 수 있다. 게이트웨이가 브로커에 통합되지 않은 경우 게이트웨이는 MQTT프로토콜을 사용하여 브로커와
통신한다.
-게이트웨이가 MQTT와 MQTT-S간의 프로토콜 변환을 수행하는 방법에 따라 두 가지 유형의 게이트웨이, 즉 transparent GW와 
aggregating GW를 구분할 수 있다.
-Transparent Gateway; 연결된 각 MQTT-S 클라이언트에 대해 transparent GW는 MQTT브로커에 대한 MQTT 연결을 설정하고 유지한다.
GW에 연결된 MQTT-S 클라이언트 수만큼 GW와 브로커 사이에 많은 MQTT 연결이 있다. transparent GW는 두 프로토콜 간에 "변환"을
수행한다. 모든 MQTT-S 메시지는 MQTT 메시지에 매핑될 수 있고 그 반대도 마찬가지이므로 브로커가 구현하는 모든 기능과 특징을 클라이언트에
제공할 수 있다.
-Aggregating Gateway; 연결된 각 클라이언트에 대해 MQTT연결을 사용하는 대신, Aggregating GW는 브로커에 대해 하나의 MQTT연결만
갖게된다. MQTT-S 클라이언트와 Aggregating GW간의 모든 메시지 교환은 GW에서 끝난다. 이후 GW는 브로커에게 추가로 전송할 정보를 
결정한다.
-Transparent GW의 구현은 Aggregation GW의 구현보다 간단하지만 TGW의 주요 문제는 연결된 클라이언트 수 측면에서 시스템 확장성이다.
게이트웨이와 브로커는 모든 활성 클라이언트에 대한 연결을 유지해야 하기 때문에 SA장치가 매우 많은 네트워크에서는 성능이 저하될 수 있다.
AGW는 브로커가 동시에 지원해야하는 MQTT 연결수를 크게 줄일 수 있으므로 도움이 될 수 있다.

-Support for multiple Gateway
-SA장치와 게이트웨이 간의 링크는 언제든지 실패할 수 있으므로 브로커에서 SA장치의 연결이 끊어진다. 따라서 SA 장치는 적어도 두개의 
게이트웨이에 액세스 할 수 있어야 한 게이트웨이 대한 연결이 실패하면 다른 게이트웨이를 통해 다시 연결할 수 있도록 하는 것이 매우 
바람직한다. 적어도 두 개의 게이트웨이가 있어야 하는 또 다른 이유는 무선 링크의 낮은 전송 용량 때문이다. 많은 수의 SA가 해당 게이트웨이와
메시지를 교환하는 경우 게이트웨이 근처의 링크가 정체될 수 있다. 둘 이상의 게이트웨이가 있으면 브로커로 향하는 트래픽이 게이트웨이 간에
고르게 분산될 수 있으므로 이러한 상황을 해결하는데 도움이 된다. WSN은 게이트웨이를 통해 보다 강력한 기존 네트워크에 연결된다.
-MQTT-S는 게이트웨이 검색 절차를 통해 여러 게이트웨이의 존재를 지원한다. 게이트웨이를 찾기위해 클라이언트는 SEARCHGW메시지를
브로드캐스타하고 게이트웨이는 GWINFO메시지를 통해 응답한다. 클라이언트는 게이트웨이 주소가 있는 경우에도 GWINFO메시지로 응답한다.
게이트웨이에 우선순위를 부여하고 메시지 수를 줄이기 위해 클라리언트는 임의 시간 동안 전송을 지연한다. 이 지연 시간 동안 다른 노드
(게이트웨이 또는 클라이언트)에서 보낸 GWINFO 메시지를 받으면 응답을 보내지 않는다. 따라서 절차는 대역폭에 매우 효율적이다. 
단일 SEARCHGW및 GWINFO 메시지 교환은 이미 게이트웨이를 동시에 검색하는 여러 클라이언트에 필요한 정보를 제공할 수 있다. 응답이
없으면 SEARCHGW메시지가 제전송되고 두 개의 연속 전송 사이의 시간 간격이 기하 급수적으로 증가한다.
-SEARCHGW및 GWINFO 메시지는 모두 로컬로 브로드캐스트된다. 즉, 수신 노드에서 반복되지 않는다. 이 원홉 브로드캐스팅을 통해
무선 전송의 고유한 브로드캐스트 특성을 활용하여 발신자의 전송 범위 내의 모든 노드에 메시지를 전송한다. 이러한 브로드캐스트에 사용되는 
추가 대역폭은 없다.

-Support of short messge payload(payload; 사용에 있어서 전송되는 데이터를 의미. 큰 데이터 덩어리 중에 흥미 있는 데이터를 구별하는데 사용된다)
-무선 네트워크의 또 다른 문제는 패킷이 매우 짧다. (패킷; 예를 들면 트럭정도에 해당, 트럭이 짐을 싣고 보낼때 어디로 출발하는지, 경로는
어느곳인지, 어떤 물건을 담는지에 대한 정보를 갖고 있어야함. 또한 한번에 들어갈 수 있는 정도의 양만 싣을 수 있음). MQTT는 클라이언트ID
및 주제 이름에 대해 사람이 읽을 수 있는 문자열을 사용한다. 특히 두 개의 메시지가 상당히 길어질 수 있다. 첫번째 클라이언트 ID, WILL 주제,
WILL 메시지의 세가지 큰 매개 변수를 포함할 수 있는 CONNECT 메시지. 두번째는 주제 이름과 잠재적으로 큰 데이터 필드를 포함하는
PUBLISH 메시지
-원칙적으로 이 문제를 해결하기 위한 세가지 접근 방식이 있다. 첫번째는 일반적인 분할 및 재조립 절차를 정의하는것이다. 분할 및 재조립
예; ATM,TCP/IP, Bluetooth등에 사용된다. 이 방법을 구현하기 위한 프로토콜과 알고리즘은 잘 알려져 있다. 하지만 클라이언트의 메모리
공간을 증가 시키고 메시지에 추가 오버헤드가 필요하기 때문에 어플리케이션 페이로드가 줄어드므로 거부되었다. 대부분의 경우 동일한
주제 이름을 포함하는 PUBLISH 메시지와 같은 메시지에 의해 소비되는 낭비도니느 대역폭을 줄이지 않는다.
-두번째 방법은 긴 메시지를 여러개의 짧은 메시지로 분할하는 것이다. 이 아이디어를 CONNECT 메시지에 적용하고 이 메시지를 세개의
작은 메시지로 나누다. 첫번째는 Client ID에 대한 문자열을 전달하고, 두번째는 WILL주제를, 세번째는 WILL메시지를 전달한다.
-그러나 PUBLISH 메시지에는 이 접근 방식을 적용하지 않는다. 매번 같은 주제 이름을 보내서 낭비되는 대역폭을 줄이는데 여전히 도움이
되지 않기 때문이다. 이러한 중복 정보를 제거하기 위해 주제 이름을 2 바이트 길이의 짧은 "주재 ID"로 바꾸고 클라이언트가 게이트웨이에
주제 이름을 등록하고 할당된 주제 ID를 얻을 수 있도록 등록 절차를 정의한다. 이 주제 이름을 등록한 후 클라이언트가 보낸 PUBLISH메시지에는
더 긴 주제 이름 대신 할당된 짧은 주제 ID가 포함된다 이 주제가 포함된 PUBLISH 메시지를 클라이언트에게 보내기 전에 클라이언트에게
새 주제 이름을 알리기 위해 반대 방향의 게이트웨이에서도 동일한 절차를 사용한다.
-위 절차에서는 클라이언트가 게이트웨이의 다른 토픽에 할당된 토픽ID를 잘못 사용할 위험이 있다. 게이트웨이가 주제 ID 대 주제 이름 매핑에
대한 단일 테이블을 사용할 때 발생할 수 있다. 그러나 클라이언트의 구현을 단순하게 유지하기 위해 주제 ID동기화 알고리즘을 정의하지 않는다.
대신 게이트웨이에서 각 클라이언트에 대해 전용 매핑 테이블을 구현하는 것을 선호한다. 이 솔루션을 사용하면 클라이언트가 잘못 된 토픽ID를 
사용할 확률이 거의 0으로 줄어든다.
-클라이언트의 구현을 더욱 단순화 하기 위해 사전 정의된 주제ID를 도입하여 클라이언트가 주제의 사전 등록 없이 즉시 게시에 사용할 수 있다.
이 경우 게이트웨이에 있는 주제ID의 매핑 테이블은 관리자가 미리 구성한다.



