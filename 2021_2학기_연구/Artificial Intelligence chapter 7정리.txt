Artificial Intelligence Chapter 7.

Rule based deduction system
-Rule based 문제 해결 시스템은 다음과 같은 규칙을 사용하여 구축되며, 각 규칙에는 여러 if 패턴과 하나 이상의 then 패턴이 포함된다
-기호는 적절하게 디지털 전자 장치에서 AND게이트에 사용되는 것과 동일하다.

Many rule based system are deduction system
-모든 규칙 기반 시스템에서 각각의 if 패턴은 assertions 모음에 있는 하나 이상의 assertion과 일치할 수 있는 패턴이다. assertion collection을
working memory라고 부른다.
(연역; 이미 알고 있는 판단을 근거로 새로운 판단을 유도하는 추론, 여기서 이미 알고 있는 판단은 전제, 새로운 판단은 결론이다.)
-많은 rule-based 시스템에서 then 패턴은 working memory에 배치할 새 aseertion을 지정하며 rule-based 시스템을 deduction(연역)
시스템이라고 한다. deduction 시스템에서 규칙은 각각의 if 패턴(조건/원인)을 antecedent 각 then 패턴(결론/결과)을 consequent로 참조한다.
-그러나 때때로 then 패턴은 "항목을 가방에 넣으십시오"와 같이 말 대신 행동을 지정한다. 이 경우 rule-based 시스템은 reaction 시스템이다.
-Deduction 시스템과 reaction 시스템 모두에서 forwarding chaining은 if 패턴에서 then 패턴으로 이동하는 과정이며, if 패턴을 사용하여
새로운 주장이나 행동의 수행에 대한 적절한 상황을 식별한다.
*fact와 assertion은 미묘하게 다르다. fact는 사실로 알려진것이고, assertion은 어떤 것이 사실이라는 진술이다. 따라서 assertion은 거짓일 수 있다
하지만 fact는 거짓일 수 없다.
-forward chaining동안 if 패턴이 assertion과 일치하는 것으로 관찰될 때마다 antecedent 조건이 충족된다. 규칙의 모든 if 패턴이 충족
될 때마다 규칙이 trigger된다. trigger된 규칙이 새 assertion을 설정하거나 작업을 수행할 때마다 실행된다.
-Deduction(연역, 추론) 시스템에서 모든 trigger된 규칙은 일반적으로 실행된다. 그러나 reaction 시스템에서 둘 이상의 규칙이 동시에 트리거 되면
일반적으로 가능한 작업 중 하나만이 필요하므로 어떤 규칙이 fire(실행)되어야 하는지를 결정하기 위해 일종의 conflict resolution procedure가 
필요하다.
(deduction system; 연역 추론, 만일 전제가 true이면 결론도 반드시 true, 결론에서 진술되는 모든 내용은 이미 전제속에 포함되어 있다.)
(Induction system; 귀납법, 만일 전제가 true이면, 결론은 확률적으로는 true이나 필연적으로 true는 아니다. 결론의 내용이 전제속이
포함되어있지 않다)
(trigger; 어느 특정한 동작에 반응해 자동으로 필요한 동작을 실행한다는 의미)
(conflict resolution procedure; 충돌 해결 절차, 갈등 해결 절차, fire; 실행)

A toy deduction system identifies animals
-로봇인 robbie가 동물원에서 하루를 보내고 싶어한다고 가정하자. Robbie는 색과 크기, 동물의 머리카락이 있는지 또는 우유를 주는지와 같은
기본 기능을 인식할 수 있지만 이러한 기능을 사용하여 물체를 식별하는 능력은 제한적이다. Robbie는 동물을 다른 물체와 구별할 수 있지만,
짝을 이루는 동물이 목이 길다는 사실을 이용하여 Robbie가 기린을 보고 있다는 결론을 내릴 수는 없다.
-Robbie가 개별 동물을 식별할 수 있기 위해 identification-oriented deduction system은 Zookeeper를 구축한다.
-Robbie는 동물원에 있는 각 동물 종류에 대해 하나의 if-then 규칙을 만들어 Zookeeper를 만들 수 있다. 각 규칙의 consequent 측면은
동물의 정체성에 대한 단순한 assertion이 될 것이고, antecedent 측면은 모든 잘못된 식별을 거부할 수 있을 만큼 충분히 완전한
특성의 구근(뿌리)가 열거가 될 것이다.
-그러나 Robbie는 중간 assertion을 생성하는 규칙을 생성하여 Zookeeper를 구축하기로 결정한다. 장점은 관련된 antecedent-consequent
규칙이 필요로 하는 antecedent 조건이 적기 때문에 Robbie가 더 쉽게 만들고 사용할 수 있다는 것이다. 이 접근 방식을 사용하여 Zookeeper는 
Robbie가 현재 검사중인 동물의 식별에 이르는 chains of conclusion을 생성합니다.
-이제 Robbie의 지역 동물원에 치타, 호랑이, 기린, 얼룩말, 타조, 펭귄, 알바트로스등 7마리 동물만 있다고 가정한다. 이 가정은
Zookeeper를 단순화 한다. 한 동물 유형을 다른 동물과 구별하는데 몇 가지 규칙만 필요하기 때문이다. 그러한 규칙중 하나인 규칙 Z1은
특정 동물이 포유류 라고 결정한다.
Z1; 	If 	?x has hair
	then 	?x is a mammal
-antecedent와 consequent가 물음표 접두사로 표시된 x와 같은 변수를 포함하는 패턴입니다. 규칙이 고려될 때마다 해당 변수에는
처음에는 값이 없지만 antecedent 패턴이 assertion과 일치함에 따라 값을 얻는다.
-Stretch라는 이름의 특정 동물에 머리카락이 있다고 가정한다. working memory에 Stretch가 hair가 있다는 주장이 포함되어 있으면
antecedent 패턴은 ?x has hair가 해당 주장과 일치하고 x의 값은 Stretch가 된다. 관례에 따라 변수가 값으로 식별되면 해당 값에 binding된다고 하며
값을 binding이라고 한다. 따라서 x는 Stretch에 binding 되고, Stretch는 x의 바인딩 이다.
(바인딩; 어떤 기본 단위가 가질 수 있는 구성 요소의 구체적인 값, 성격을 확정하는 것을 말한다)
-변수가 바인딩 되면 변수가 동일하거나 이후에 처리되는 패턴에 나타날 때마다 변수가 바인딩으로 대체된다. 패턴의 변수가 변수 바인딩으로 대체될 때마다
패턴이 instantiated(객체화, 추상화) 된다고 한다. 예를 들어 결과 패턴 ?x는 포유류가 된다. Stretch는 antecedent 패턴이 일치할 때 
획득한 variable binding에 의해 instantiated 되면 포유류 입니다.
-이제 다른 Zookeeper 규칙을 살펴보겠습니다. 
Z2;	if 	?x gives milk
	then 	?x is a mammal

Z3; 	if 	?x has feathers
	then 	?x is bird

z4;	if 	?x flies
	   	?x lays egges
	then 	?x is a bird

-이 규칙의 마직막인 Z4에는 두 가지 antecedent 조건이 있다. Zookeeper의 세계에 있는 작은 동물 컬렉션에는 실제로 중요하지 않지만 
일부 포유류는 날고 일부 파충류는 알을 낳지만 어떤 포유류나 파충류도 둘 다 하지는 않는다. 사육사는 동물이 포유류라는 것을 알게되면
두 가지 규칙에 따라 해당 동물이 육식성인지 여부가 결정된다.더 간단한 규칙은 저녁을 먹는 행위에서 동물을 잡아 먹는 것과 관련이 있다.
Z5;	if 	?x is a mammal
	   	?x eats meat
	then 	?x is a carnivore(육식동물)
-Robbie가 먹이를 줄 때 동물원에 있지 않으면 가능한 경우 다양한 다른 요인이 결정적인 증거를 제공한다.
Z6; 	if 	?x is a mammal
	   	?x has pointed teeth
	   	?x has claws
	   	?x has forward-pointing eyes
	then 	?x is a carnivore
-모든 발굽이 있는 동물은 유제류이다.
Z7;	if 	?x is a mammal
	   	?x has hoofs
	then 	?x is an ungulate
-Robbie가 발을 보는데 어려움을 겪더라도 새김질을 하는 모든 동물은 유제류이기 때문에 Zookeeper는 여전히 기회를 가질 수 있다.
Z8; 	if 	?x is a mammal
	   	?x chews cud
	then ?	x is an ungulate(유제류)
-Robbie가 포유류를 육식 동물과 유제류로 나누는 규칙이 있다는 것이 아니다. 이제는 특정 동물의 정체성을 식별하는 규칙을 추가해아할 
때이다. 육식 동물의 경우 두 가지 가능성이 있다.
Z9;	if 	?x is a carnivore
	   	?x has tawny color
	   	?x has dark spots
	then 	?x is a cheetah
Z10;	if 	?x is a carnivore
	   	?x has tawny color
	   	?x has black strips
	then 	?x is a tiger
-엄밀히 말하면, 기본 색상은 둘 다 황갈색이기 때문에 유용하지 않다. 그러나 규칙의 정보가 최소화될 필요는 없다. 게다가 지금은 불필요했던
antecedent가 나중에 다른 동물을 다루는 새로운 규칙이 추가됨에 따라 필수적이 될 수 있다. 유제류의 경우 다른 규칙은 전체 그룹을 두 가지 
가능성으로 분리한다. 
Z11;	if 	?x is an ungulate
	   	?x has long legs
	   	?x has long neck
	   	?x has tawny color
	   	?x has dark spots
	then 	?x is a giraffe
Z12;	if 	?x is an ungulate
	   	?x has white color
	   	?x has black stripes
	then 	?x is a zebra
-새를 다루려면 세 가지 규칙이 더 필요하다
Z13;	if 	?x is a bird
	   	?x does not fly
	   	?x has long legs
	   	?x has long neck
	   	?x has black and white
	then 	?x is an ostritch
Z14;	if 	?x is a bird
	   	?x does not fly
	   	?x swims
	   	?x is black and white
	then 	?x is a penguin
Z15; 	if 	?x is a bird
	   	?x is a good flyer
	then 	?x is an albatross

-Zookeeper의 모든 규칙을 보았으므로 동물은 분명히 많은 기능을 공유한다. 얼룩말과 호랑이는 검은 줄무늬가 있다. 호랑이, 치타, 기린은
황갈색이다. 기린과 타조는 긴 다리와 긴 목을 가지고 있다. 타조와 펭귄은 흑백이다.
-forward chainning이 작동하는 방법에 대해 배우기 위해 Robbie가 동물원에 있고 Zookeeper를 사용하여 미지의 동물 Stretch를 분석하려고
한다고 가정한다. 또한 다음 6개 assertion이 working memory에 있다고 가정한다.
Stretch has hair
Stretch chews cud
Stretch has long legs
Stretch has a long neck
Stretch has tawny color
Stretch has dark spots
-Stretch는 머리카락이 있기 때문에 규칙 Z1이 실행되어 Stretch가 포유류임을 확인한다. Stretch가 포유류이고 되새김질을 하기 때문에
규칙 Z8은 Stretch가 유제류임을 확립한다. 이 시점에서 규칙 Z11에 대한 모든 antecedent 조건이 충족된다. 분명히 Stretch는 기린이다.

Rule based system use a working memory and a rule base 
-Zookeeper 시스템에서 보았듯이 rule-based system의 핵심 표현 중 하나는 working memory이다
-Working memory는 다음과 같이 표현된다.
->어휘적으로 assertion과 응용 프로그램별 기호가 있다. 패턴 기호와 혼합된 응용 프로그램별 기호를 포함하는 패턴도 있다.
->구조적으로 assertion은 어플리케이션 별 기호 목록이다
->의미상, assertion은 어떤 세계의 사실을 나타낸다.
->working memory에 assertion을 추가한다.
그런 독자들과
->패턴이 주어지면 working memory에서 일치하는 assertion목록을 생성한다.

또 따른 핵심 표현은 rule base이다.

다른 주요 표현은 rule base이다.
->working memory가 있다.
->어휘적으로 rule이 있다.
->구조적으로 rule은 패턴으로 구성된다. 이러한 패턴 중 일부는 rule의 if 패턴을 구성한다. 나머지는 rule의 then 패턴을 구성한다.
->의미상, rule은 절차가 새로운 assertion을 찾거나 가설을 검증할 수 있도록 하는 제약 조건을 나타낸다.

생성자와 함께
->if 패턴과 then 패턴의 순서가 지정된 목록이 주어지면 rule을 구성한다.

그런 독자들과
->주어진 규칙의 if 패턴 목록 생성
->주어진 규칙의 then 패턴 목록 생성

-따라서 Zookeeper는 동물 식별에 특화된 이러한 표현의 instance를 사용한다. Zookeeper 자체는 다음과 같이 절차적 영어로 표현할 수 있다.
그림 7.2; 미지의 동물에 대해 아는 것은 forward chaining을 통해 식별을 가능하게 한다. 여기서 왼쪽의 주장은 미지의 동물이 기린이라는
결론으로 이어진다.
-Zookeeper(forward-chainning 버전)으로 동물을 식별하려면,
->새로운 assertion을 하는 rule이 없거나 동물이 식별될 때까지
->각 rule에 대해서
->알려진 fact와 일치시켜 rule의 각 antecedent 조건을 뒷받침 하십시오.
->rule의 모든 antecedent 조건이 지원되는 경우 동일한 assertion이 이미 존재하지 않는 한 consequent를 주장한다.
->모든 일치 및 instance화 대안에 대해 반복한다.

-따라서 assertion은 그림 7.2에 기록된 역사에서 볼 수 있듯이 주어진 assertion에서 consequent에 이르는 일련의 antecedent-consequent rule을
통해 흐른다. inference net라고도 하는 이러한 다이어그램에서 D형 개체는 규칙을 나타내는 반면 수직 막대는 주어진 주장(사실을 의미)을 나타내고, 
수직 상자는추론된 주장(결정된 주장)을 나타낸다.

Deduction systems may run either forward or backward
-지금까지 주어진 assertion에서 새로운 deduced assertion에 이르기까지 작동하는 deduction oriented rule based system에 대해 배웠습니다. 
이런 식으로 실행하면 시스템이 forward-chaining을 나타냅니다. backward-chaining도 가능합니다: rule-based system은 가설을 형성하고 가설을 
뒷받침하는 assertion을 향해 backward로 작업하기 위해 antecedent-consequent rule을 사용할 수 있습니다.
-예를 들어, Zookeeper는 주어진 동물 Swifty가 치타라는 가설을 세우고 그 가설이 실행 가능한지 추론할 수 있습니다. 
다음은 이러한 backward-chaining 접근 방식에 따라 작동하는 방식을 보여주는 시나리오입니다.

- 사육사는 스위티가 치타라는 가설을 세웁니다. 이 가설을 확인하기 위해 Zookeeper는 Swifty는 육식 동물이고, Swifty는 황갈색이고,
Swifty에는 어두운 점이 있어야 한다는 규칙 Z9를 고려합니다.
- 사육사는 스위티가 육식동물인지 확인해야 합니다. 두 가지 규칙, 즉 규칙 Z5와 규칙 Z6이 작업을 수행할 수 있습니다. 
Zookeeper가 Z5 규칙을 먼저 시도한다고 가정합니다.
- 사육사는 스위티가 포유류인지 확인해야 합니다. 다시, 규칙 Z1과 규칙 Z6의 두 가지 가능성이 있습니다. Zookeeper가 Z1 규칙을 
먼저 시도한다고 가정합니다. 그 규칙에 따르면, Swifty에 머리카락이 있으면 Swifty는 포유류입니다.
- 사육사는 스위티에게 털이 있는지 확인해야 합니다. Zookeeper는 Swifty에 머리카락이 있다는 것을 이미 알고 있다고 가정합니다. 
따라서 Swifty는 포유류여야 하며 Zookeeper는 Z5 규칙 작업으로 돌아갈 수 있습니다.
- 사육사는 스위티가 고기를 먹는지 확인해야 합니다. Zookeeper가 현재로서는 말할 수 없다고 가정합니다. 따라서 사육사는 
규칙 Z5를 포기하고 규칙 Z6을 사용하여 Swifty가 육식 동물임을 확인해야 합니다.
- 사육사는 스위티가 포유류인지 확인해야 합니다. Swifty는 규칙 Z5의 antecedent 조건을 충족시키려고 할 때 이미 설정되었기 때문에 
포유류입니다.
- 사육사는 Swifty가 뾰족하고, 이빨이 있고, 발톱이 있고, 앞을 가리키는 눈이 있는지 확인해야 합니다. Zookeeper는 Swifty에 이러한 
모든 기능이 있다는 것을 알고 있다고 가정합니다. 분명히 Swifty는 육식 동물이므로 Zookeeper는 지금까지 모든 작업을 시작한 
Z9 규칙으로 돌아갈 수 있습니다.
- 이제 사육사는 Swifty에 황갈색과 검은 반점이 있는지 확인해야 합니다. Zookeeper는 Swifty에 두 가지 기능이 모두 있다는 것을 
알고 있다고 가정합니다. 따라서 규칙 Z9는 Swifty가 치타라는 원래 가설을 지원하므로 Zookeeper는 Swifty가 치타라고 결론을
내립니다.

-따라서 Zookeeper는 원하는 consequent를 사용하여 어떤 assertion을 보여야 하는지 결정하여 antecedent-consequent rule을 통해 
backward로 작업할 수 있습니다.  다음 절차에 따라 backward로 움직이는 chaining이 발달합니다.
-그림 7.3: 미지의 동물에 대해 아는 것은 backward-chaining를 통한 식별을 가능하게 합니다. 여기에서 Swifty가 치타라는 가설은 
그 가설을 뒷받침하는 assertion으로 이어집니다.

-Zookeeper(backward-chainning 버전)로 동물을 식별하려면,
-> 모든 가설이 시도되고 아무 것도 지지되지 않거나 동물이 확인될 때까지,
-> 각 가설에 대해,
-> 결과가 현재 가설과 일치하는 각 규칙에 대해,
-> working memory의 assertion과 일치시키거나 다른 규칙을 통해 backward chaining을 통해 새로운 가설을 생성함으로써 각 rule의 
antecedent 조건을 지원하십시오. 모든 일치 및 인스턴스화 대안을 확인하십시오.
->규칙의 모든 antecedent 조건이 지지되면 성공을 선언하고 가설이 참이라고 결론을 내립니다.
-이 예에서 bakcward chaining는 성공적으로 종료되어 그림 7.3과 같이 가설을 검증합니다. 필요한 antecedent assertion을 지원할 수 
없는 경우 연결이 성공적으로 종료됩니다.

The Problem Determines Whether Chaining should Be Forward or Backward
-많은 deduction-oriented, antecedent-consequent rule 시스템은 forward or backward로 연결될 수 있지만 어느 방향이 더 나은가?
-일반적인 사실 집합이 많은 결론으로 이어질 수 있는 규칙이 있을 때마다 rule system은 높은 수준의 fan-out을 나타내고 높은 수준의
fan-out은 역방향 연결을 주장한다. 반면에 rule이 일반적인 가설이 많은 질문으로 이어질 수 있을 때마다 rule system이 높은 수준의
fan in을 나타내고 높은 수준의 fan-in은 순방향 연결을 주장한다.

-당신이 가지고 있거나 확립할 수 있는 사실이 많은 결론을 이끌어 낼 수 있지만 당신이 관심 있는 특정 결론에 도달하는 방법의 수가 적다면
fan in 보다 fan out이 더 많으며 backward chaining을 사용한다.
-관심이 있는 특정 결론에 도달하는 방법의 수는 많지만 사실을 사용하여 도달할 가능성이 있는 결론의 수가 적은 경우 fan-out 보다
fan-in이 더 많으며 forward chaining을 사용해야 한다.
(fan-in; 자신이 갖고 있는 사실의 수, fan-out; 자신이 추론할 수 있는 가설의 수)

-물론 많은 상황에서 fan out도 fan in도 지배적이지는 않다 다른 고려사항:
-아직 수집한 사실이 없고, 관심만 있는 경우 가능한 많은 결론 중 하나가 참인지 여부에 관계없이 backward chaining을 사용하십시오
-예를 들어 동물의 정체에 대해 관심이 없다고 가정한다. 당신이 걱정하는 것은 그것이 육식 동물인지 여부이다. 육식 동물 가설에서
backward chaining을 통해 수집한 모든 사실에 적절하게 초점을 맞출 수 있다. 동물의 이빨에 대해 물어볼 수는 있지만 동물의 색깔은
절대 묻지 않을 것이다.

-만약 당신이 얻게될 모든 사실을 이미 가지고 있고 그 사실로부터 결론을 내릴 수 있는 모든 것을 알고 싶다면 forward chaining을 
사용하십시오
-예를 들어, 당신이 나중에 사라진 동물을 잠깐 보았다고 가정해보자, 당신은 동물에 대해 무엇을 추론할 수 있는지 알고 싶다. 만약
당신이 backward chaining으로 연결된다면, 당신은 동물이 사라졌기 때문에 더 이상 대답할 수 없는 질문으로 이어지는 가설을
추구하는데 시간을 낭비하게 될 것이다. 따라서 forward chaining을 하는 것이 좋다.

Rule Based Reaction System
-Deduction 시스템에서 일부 if then 규칙의 if 부분은 assertion의 조합을 지정한다. then 부분은 추론할 새로운 assertion을 지정한다.

Mycin Diagnoses Bacterial Infections of the Blood
-Zookeeper는 잘 알려진 rule-based deduction 시스템인 MYCIN을 기반으로 한다. 역사적으로 MYCIN시스템은 rule-based 전문가
시스템에 대한 연구 관심을 자극하는데 중요한 역할을 한다.
-MYCIN의 전문성은 박테리아 감염 영역에 있다. 의사는 일반적으로 어떤 유기체가 범인인지 정확하게 알지 못한채 세균 감염이 있는
환자에 대해 항생제 치료를 시작해야 한다. 너무 천천히 축적되는 확실한 실험실 배양 증거를 기다릴 시간이 없다. 중환자의 경우,
치료는 한번에 2일이 아니라 즉시라도 시작해야 한다. 이 요구 사항은 두 가지 선택을 남긴다. 의사는 모든 가능성을 포괄하는
광범위한 약물을 처방하거나 더 나은 질병 특이적 약물을 처방할 수 있다.
-MYCIN은 의사가 질병에 특정한 약을 처방하도록 도와준다. MYCIN은 쉽고 빠르게 얻을 수 있는 환자의 증상, 전반적인 상태, 병력 및
실험실 검사 결과에 대한 정보를 의사에게 요청하여 특정 사례에 대해 자체적으로 알려준다. 각 지점에서 MYCIN이 묻는 질문은
MYCIN의 현재 가설과 모든 이전 질문에 대한 답변에 의해 결정된다. 따라서 질문은 체크리스트에서 가져온 것처럼 시작되지만
증거가 구축됨에 따라 질문이 달라진다.
> What is the patient’s name?
>John Doe.
> Male or female?
Male.
> Age?
He is 55.
> Have you obtained positive cultures indicating general type?
>Yes.
> What type of infection is it?
Primary bacteremia.
> When did symptoms ﬁrst appear?
May 5.
> Let’s call the most recent positive culture C1. From what site was C1 taken?
From the blood.
> When?
May 9.
> Let’s call the ﬁrst signiﬁcant organism from this culture U1. Do you know the identity of U1?
No.
> Is U1 a rod or a coccus or something else?
Rod.
> What is the gram stain of U1?
Gram-negative.
> Have there been positive cultures from sites that are not associated with the infections about which you are seeking advice?
No.
> Did U1 grow aerobically?
Yes

-상황이 합리적으로 잘 파악하고 있다고 판된되면 MYCIN은 진단을 발표한다.
>My recommendations will be based on the opinion that the identity of U1 may be
1. Pseudomonas-aeruginosa
2. Klebisella-pneumoniae
3. E.coli
4. Bacteroides-fragilis
5. Enterobacter
6. Proteus-nonmirabilis.

-MYCIN의 지식 범위는 약 500개의 antecedent-consequent 규칙으로 구성되어 MYCIN이 세균 감염의 약 100가지 원인을 인식할 수 있도록 한다.
M88	If 	?x type is primary bacteremia
	   	the suspected entry point of ?x is the gastrointestinal tract
	   	the site of the culture of ?x is one of the sterile sites
	   	the site of the culture of ?x is one of the sterile sites
	then 	there is evidence that ?x is bacteroides
-의사는 한번에 하나의 가설을 생각하는 것을 선호하기 때문에 MYCIN은 역방향 연결 시스템이다. 특정 가설적 결론과 관련된 질문을 
고수함으로써 질문은 그 가설과 관련성을 유지하도록 보장된다. forward chaining 시스템은 무작위로 보이는 것처럼 먼저 한 결론을
향해 작업한 다음 다른 결론을 향해 작업하면서 이리저리 뛰어다닐 수 있다.
-MYCIN이 backward chaining 시스템으로 설계된 또 다른 이유는 backward chaining이 영어 인터페이스 생성을 단순화 하기 때문이다. 
인터페이스는 자유로운 형식의 상상력이 풍부한 텍스트가 아닌 특정 질문에 대한 답변만 처리하면 된다.
-이 섹션에 소개된 reaction 시스템에서 if 부분은 충족되어야 하는 조건을 지정하고 then 부분은 수행할 작업을 지정한다. 때로는 새로운
assertion을 추가한다. 때로는 기존 assertion을 삭제한다. 때로는 assertion을 전혀 포함하지 않는 절차를 실행한다.

A Toy Reaction System Bags Grocery
-Robbie가 식료품점에서 식료품을 포장하는 일을 막 고용했다고 가정해 봅시다.
-그는 식료품 포장에 대해 거의 알지 못하기 때문에 각 품목이 어디로 가야 하는지를 결정하는 규칙 기반 반응 시스템인 BAGGER를 
만들어 새로운 직업에 접근합니다.
-약간의 연구 끝에 Robbie는 BAGGER를 4단계로 설계해야 한다고 결정했습니다.
1. The check-order step: 
BAGGER는 고객이 선택한 것을 분석하고 식료품을 살펴보고 고객에게 추가할 품목을 제안하기 위해 누락된 품목이 있는지 확인합니다.
2. The bag-large-items step:
BAGGER는 큰 물건을 먼저 가방에 넣고 큰 병을 조심스럽게 넣습니다.
3. The bag-medium-items step:
BAGGER는 중형 품목을 백에 담아 냉동된 품목을 냉동실 백에 넣습니다.
4. The bag-small-items step:
BAGGER는 작은 물건을 가방에 넣습니다.

-이제 이 지식을 reul based reaction system에서 캡처하는 방법을 살펴보겠습니다. 첫째, BAGGER에는 working memory가 필요합니다. 
working memory는 가방에 넣을 항목에 대한 정보를 캡처하는 assertion을 포함해야 합니다. 이러한 항목이 다음 표에 나열된 항목이라고 
가정합니다.

Item 		Container type 	Size 	Frozen?
Bread 		plastic bag 	medium 	no
Glop 		jar 		small 	no
Granola 		cardboard box 	large 	no
Ice cream 	cardboard carton 	medium 	yes
Potato chips 	plastic bag 	medium 	no
Pepsi 		bottle 		large 	no

-다음으로 BAGGER는 어떤 단계가 현재 단계인지, 어떤 가방이 현재 가방인지, 어떤 항목이 이미 가방에 담겨 있는지 알아야 합니다. 
다음 예에서 첫 번째 주장은 최근 단계를 check-order step으로 식별하고 두 번째 주장은 가방을 Bag1으로 식별합니다. 
나머지는 아직 포장되지 않은 품목을 나타냅니다.

Step is check-order
Bag1 is a bag
Bread is to be bagged
Glop is to be bagged
Granola is to be bagged
Ice cream is to be bagged
Potato chips are to be bagged

-working memory에는 단계를 식별하는 aseertion이 포함되어 있습니다. BAGGER의 규칙 베이스에 있는 각 규칙은 단계 이름을 
테스트합니다.  예를 들어 규칙 B1은 단계가 check-order step인 경우에만 트리거됩니다.

B1 	If 	step is check-order
	   	potato chips are to be bagged
	   	there is no Pepsi to be bagged .
	then 	ask the customer whether he would like a bottle of Pepsi

-규칙 B1의 목적은 감자 칩이 건조하고 짠 것이기 때문에 고객이 감자 칩과 함께 마실 것을 확실히 하는 것입니다.
-규칙 B1의 최종 조건은 특정 패턴이 working memory의 assertion과 일치하지 않는지 확인합니다.
-이제 BAGGER를 체크 주문 단계에서 bag-large-items 단계로 이동하는 규칙으로 이동해 보겠습니다.

B2 	If 	step is check-order
	then 	step is no longer check—order
	       	step is bag-large-items

-규칙 B2의 첫 번째 작업은 working memory에서 aseertion을 삭제합니다. Deduction system은 참으로 밝혀진 것이 거짓이 될 수 없는 
정적인 세계를  다룬다고 가정합니다. 반응 시스템 그러나 더 많은 자유가 허용됩니다. 때로 그 추가 자유는 then으로 표시된 
규칙의 작업 부분을 삭제 및 추가로 표시된 두 개의 구성 부분으로 분리하여 규칙 구문에 반영됩니다. 
이 대체 구문을 사용하는 경우 규칙 B2는 다음과 같습니다.

B2 (add-delete form)
If 	step is check-order
delete 	step is check-order
add 	step is bag-large-items

-BAGGER의 나머지 규칙은 이 더 투명한 추가-삭제 구문으로 표현됩니다.
-처음에는 규칙 B2가 위험해 보일 수 있습니다. 규칙 B1이 합법적이고 필요한 작업을 수행하는 것을 방해할 수 있기 때문입니다. 
그러나 문제가 없습니다. reaction system으로 작업할 때마다 적절한 충돌 해결 절차를 채택하여 트리거될 수 있는 많은 규칙 중에서 실행할 
규칙을 결정합니다. BAGGER는 가장 단순한 충돌 해결 전략인 rule 순서를 사용합니다. 즉, 규칙이 목록으로 정렬되고 실행되는 첫 번째 
규칙이 실행되도록 허용됩니다. 규칙 B1 뒤에 규칙 B2를 배치하여 규칙 B2가 단계를 bag-large-item으로 변경하기 전에 규칙 B1이 
작업을 수행하도록 합니다. 따라서 규칙 B2는 다른 작업을 수행할 수 없는 경우에만 단계를 변경합니다.
-규칙 순서 충돌 해결을 사용하면 다른 방법으로도 도움이 됩니다. 예를 들어, 큰 품목을 포장하기 위한 처음 두 가지 규칙을 고려하십시오.

B3 	If 	step is bag-large-items
	   	a large item is to be bagged
	  	the large item is a bottle
	   	the current bag contains < 6 large items
	delete 	the large item is to be bagged
	add 	the large item is in the current bag
B4 	If 	step is bag-large—items
		a large item is to be bagged
		the current bag contains < 6 large items
	delete 	the large item is to be bagged
	add 	the large item is in the current bag
-큰 물건은 아직 물건이 많지 않은 가방에 들어가지만 병은 무거운 것부터 먼저 넣습니다. 규칙 B4 앞에 규칙 B3을 배치하면 이 순서가 
보장됩니다.
-규칙 B3 및 B4에는 계산이 필요한 조건이 포함되어 있으므로 BAGGER는 트리거된 규칙을 찾을 때 assertion 일치 이상을 수행해야 합니다. 
대부분의 규칙 기반 시스템은 어설션 일치에 중점을 두지만 작업 메모리의 어설션에 선행 패턴을 일치시키는 것 이상의 작업을 수행해야 
하는 경우 범용 프로그래밍 언어에 이스케이프 해지를 제공합니다.
-분명히 BAGGER는 현재 가방에 6개 미만의 항목이 포함된 경우에만 큰 항목을 추가합니다.* 현재 가방에 6개 이상의 항목이 포함된 경우 
BAGGER는 규칙 B5를 사용하여 가방을 변경합니다.

*더 나은 BAGGER 시스템은 가방이 가득 찬 시점을 확인하기 위해 부피를 사용합니다. 그러나 볼륨을 처리하려면 더 현실적이기는 
하지만 예제를 불필요하게 복잡하게 만드는 범용 계산이 필요합니다.

B5 	If 	step is bag-large—items
		a large item is to be bagged
		an empty bag is available
	delete 	the current bag is the current bag
	add 	the empty bag is the current bag

Finally, another step-changing rule moves BAGGER to the next step:

B6 	If 	step is bag-largeitems
	delete 	step is bag-largeitems
	add 	step is bag-medium-items

-주어진 데이터베이스에서 이러한 규칙을 사용한 결과를 시뮬레이션해 보겠습니다. 우리가 시작할 때, 그 단계는 체크 오더입니다. 
확인할 주문에는 감자 칩이 포함되어 있지만 펩시는 포함되어 있지 않습니다. 따라서 규칙 B1이 실행되어 고객에게 Pepsi 한 병이 
좋을 것이라고 제안합니다. 고객이 제안에 따라 펩시 한 병을 가져왔다고 가정해 보겠습니다.
-그만큼 B2 규칙 외에는 실행할 수 있는 확인 주문 규칙이 없으므로 bag-large-items의 단계로 단계를 변경하는 것이 bag-large-items가 됩니다.
-이제 Pepsi는 병에 담긴 큰 품목이므로 규칙 B3의 조건이 충족되므로 규칙 B3은 Pepsi를 현재 가방에 넣습니다. 펩시가 현재 가방에 
들어 있으면 다른 유일한 큰 품목은 규칙 B4의 조건을 충족하는 그래놀라 상자뿐이므로 다음 조건에서 작업 메모리를 남겨두고 가방에 
넣어집니다.

Step is bag-medium-items
Bag1 contains Pepsi
Bag1 contains granola
Bread is to be bagged
Glop is to be bagged
Ice cream is to be bagged
Potato chips are to be bagged

-이제 중형 품목을 포장하는 규칙을 살펴볼 차례입니다.

B7 	If 	step is bag—medium-items
		a medium item is frozen, but not in a freezer bag
	delete 	the medium item is not in a freezer bag
	add 	the medium item is in a freezer bag
 
B8 	If 	step is bag-medium—items
		a medium item is to be bagged
		the current bag is empty or contains only medium items
		the current bag contains no large items
		the current bag contains < 12 medium items
	delete 	the medium item is to be bagged
	add 	the medium item is in the current bag

B9 	If	step is bag—medium-items
		a medium item is to be bagged
		an empty bag is available
	delete 	the current bag is the current bag
	add 	the empty bag is the current bag

-규칙 B8에 나타나는 네 번째 조건은 이를 방지합니다. BAGGER는 이미 큰 품목이 들어 있는 가방에 중간 품목을 넣습니다. 큰 품목이 
들어 있는 가방이 있는 경우 규칙 B9는 새 가방을 시작합니다.
-또한 규칙 B7과 규칙 B8은 규칙 순서 충돌 해결 절차를 사용합니다. 규칙 B7과 규칙 B8이 모두 트리거되면 규칙 B7이 실행되어 
고정된 것을 보장합니다. 포장하기 전에 냉동 백에 넣습니다.
-마지막으로, 가방에 넣을 중간 품목이 더 이상 없으면 규칙 B7이 아니라 규칙 B8이 실행되지 않습니다. 
대신 규칙 B10이 트리거되고 실행되어 단계가 bag-small —items:

B10 	If 	step is bag-medium-items
	delete 	step is bag-medium-items
	add 	step is bag-small-items
-이 시점에서 모든 적절한 bag-medium-item 규칙을 실행한 후 상황은 다음과 같습니다.

Step is bag-small-items
Bag1 contains Pepsi
Bag1 contains granola
Bag2 contains bread
Bag2 contains ice cream (in freezer bag)
Bag2 contains potato chips
Glop is to be bagged

-BAGGER에서 사용하는 간단한 규칙에 따르면 중간 품목은 큰 품목이 있는 가방에 넣지 않습니다. 유사하게, 규칙 B11의 조건은 
작은 품목이 자체 가방에 들어가는 것을 의미합니다.

B11 	If 	step is bag-small—items
		a small item is to be bagged
		the current bag contains no large items
		the current bag contains no medium items
		the bag contains < 18 small items
	delete 	the small item is to be bagged
	add 	the small item is in the current bag

BAGGER needs a rule that starts a new bag:

B12 	If 	step is bag-small-items
		a small item is to be bagged
		an empty bag is available
	delete 	the current bag is the current bag
	add 	the empty bag is the current bag

-마지막으로 BAGGER에는 배깅이 완료될 때 감지하는 규칙이 필요합니다.

B13 	If 	step is bag-small-items
	delete 	step is bag-small-items
	add 	step is done

-모든 규칙을 사용한 후에는 모든 것이 bagged:

Step is done
Bag1 contains Pepsi
Bag1 contains granola
Bag2 contains bread
Bag2 contains ice cream (in freezer bag)
Bag2 contains potato chips
Bag3 contains glop

-conflict resolution이 필요한 반응 시스템 forwrad chaining추론 시스템은 conflict resolution을 위한 전략이 필요하지 않습니다. 그러나 반응 시스템에서 
둘 이상의 규칙이 트리거되면 일반적으로 가능한 작업 중 하나만 수행하기를 원하므로 실제로 실행되는 규칙을 결정하기 위해 갈등 해결 
전략이 필요합니다. 지금까지 규칙 순서 지정에 대해 배웠습니다.

-Rule Ordering: 모든 규칙을 하나의 긴 우선 순위 목록에 정렬합니다. 우선 순위가 가장 높은 트리거된 규칙을 사용합니다. 
다른 사람들은 무시하십시오.

-다음은 다른 가능성입니다.

-Context limiting: 규칙을 그룹으로 분리하여 충돌 가능성을 줄이며, 그 중 일부만 언제든지 활성화됩니다.

-Specificty ordering: 한 트리거 규칙의 조건이 다른 트리거 규칙의 조건의 상위 집합일 때마다 상위 집합 규칙이 더 구체적인 상황을 다룬다는 근거로 사용합니다.

-Data ordering:  가능한 모든 주장을 하나의 긴 우선 순위 목록에 정렬합니다. 목록에서 가장 높은 우선 순위 어설션과 일치하는 조건 패턴이 있는 트리거된 규칙을 사용합니다.

-Size ordering: 가장 까다로운 요구 사항이 있는 트리거 규칙을 사용합니다. 여기서 가장 힘든 것은 가장 긴 조건 목록을 의미합니다.

-Recency ordering: 가장 최근에 사용한 규칙을 사용합니다.

- 물론 반응 시스템에 대한 갈등 해결 전략의 적절한 선택은 상황에 따라 달라지므로 고정된 갈등 해결 전략이나 전략 조합에 의존하기 
어렵거나 불가능합니다. 대안은 해결해야 할 또 다른 문제로 어떤 규칙을 실행할지 생각하는 것입니다. 이러한 문제 해결의 우아한 
예는 SOAR 문제 해결 아키텍처의 도입부 8장에 설명되어 있습니다.

PROCEDURES FOR FORWARD AND BACKWARD CHAINING

-이 섹션에서는 규칙 기반 시스템에 대해 자세히 알아봅니다. 초점은 대체 변수 바인딩을 탐색하기 위해 잘 알려진 방법을 사용하여 
forward 및 backward 연결을 수행하는 방법에 있습니다.

-깊이 우선 검색(DFS)은 Forward chaining을 위한 호환 가능한 바인딩을 제공할 수 있습니다.

-Forward chaining을 수행하는 한 가지 간단한 방법은 규칙을 순환하면서 결과가 적절한 변수 바인딩으로 인스턴스화되면 
새 assertion으로 이어지는 규칙을 찾는 것입니다.

To forward chain (coarse version),
>Until no rule produces a new assertion,
> For each rule,
> For each set of possible variable bindings determined by matching the antecedents to working memory,
> Instantiate the consequent.
> Determine whether the instantiated consequent is already asserted. If it is not, assert it.

-예를 들어, 다음 assertion이 작업 working memory에 있다고 가정하고 zoo에서 트랙으로 전환해 보겠습니다.

Cormet 	is-a 		horse
Prancer 	is-a 		horse
Comet	is-a-parent-of 	Dasher
Comet 	is-a-parent-of 	Prancer
Prancer 	is 		fast
Dasher 	is-a-parent-of 	Thunder
Thunder	is 		fast
Thunder 	is-a 		horse
Dasher 	is-a 		horse

다음으로, fast의 parent인 horse가 가치 있다는 데 동의합시다. 이 지식을 if-then 규칙으로 변환하면 다음이 생성됩니다.

Parent Rule
	If 	?x is-a horse
		?x is-a-parent-of ?y
		?y is fast
	then 	?x is valuable

XCON Configures Computer Systems

-BAGGER는 잘 알려진 규칙 기반 공제 시스템인 XCON을 기반으로 합니다. 역사적으로 XCON 시스템은 규칙 기반 전문가 
시스템에 대한 상업적 관심을 자극하는 데 중요한 역할을 했습니다.

-XCON의 도메인은 컴퓨터 시스템 구성 요소입니다. 회사가 대형 메인프레임 컴퓨터를 구입할 때 중앙 프로세서, 메모리, 터미널, 
디스크 드라이브, 테이프 드라이브, 다양한 주변 장치 컨트롤러 및 기타 도구를 구입합니다. 이러한 모든 구성 요소는 입력-출력 버스를 
따라 적절하게 배열되어야 합니다. 또한 모든 전자 모듈은 적절한 백플레인의 적절한 종류의 캐비닛에 배치해야 합니다.

-모든 구성 요소를 정렬하는 것은 configuration이라고 하는 작업입니다. configuration 작업은 지루할 수 있습니다. 
컴퓨터 구성 요소 제품군에는 상상할 수 없는 수의 조합으로 구성할 수 있는 수백 가지 옵션이 있을 수 있기 때문입니다.

-구성을 수행하기 위해 XCON은 다음과 같은 규칙을 사용합니다.

X1 	If 	the context is doing layout and assigning a power supply
		an sbi module of any type has been put in a cabinet
		the position that the sbi module occupies is known
		there is space available for a power supply
		there is no available power supply
		the voltage and frequency of the components are known
	then	add an appropriate power supply

X2	If	the context is doing layout and assigning a power supply
		an sbi module of any type has been put in a cabinet
		the position the sbi module occupies is known
		there is space available for a power supply
		there is an available power supply
	then	put the power supply in the cabinet in the available space

-첫 번째 규칙인 X1은 주문에 감자 칩이 포함되어 있지만 음료는 없는 경우 고객에게 펩시 한 병을 원하는지 묻는 BAGGER의 규칙과 
같은 역할을 합니다. 두 번째 규칙인 X2는 일반적인 삽입 규칙입니다. 두 규칙에서 언급된 컨텍스트는 최상위 단계와 하위 단계의 
조합입니다. 컨텍스트는 다음과 같은 규칙에 의해 변경됩니다:

X3 	If 	the current context is m
	then 	deactivate the m context
		activate the y context

-규칙 X3은 컨텍스트 지정에서 한 항목을 삭제하고 다른 항목을 추가하는 효과가 있습니다. 컨텍스트 트리거와 연결된 
다른 규칙이 없는 경우에만 실행됩니다.

-XCON에는 거의 10,000개의 규칙이 있으며 Digital Equipment Corporation에서 만든 VAX 컴퓨터용 수백 가지 구성 
요소 유형의 속성을 알고 있습니다. XCON은 일상적으로 100~200개의 구성 요소와 관련된 주문을 처리합니다. 이는 
마케팅 및 제조를 위한 많은 유사한 시스템을 대표합니다.

-그림 7.4 Forward chaining 동안 바인딩 커밋은 트리에 배열될 수 있으며, 이는 일반적인 검색 방법을 사용하여 가능한 바인딩 세트 중 
하나 또는 모두를 찾을 수 있음을 시사합니다. 여기에서 상위 규칙의 첫 번째 선행 항목은 x에 대해 4개의 가능한 바인딩으로 연결되고 
규칙의 두 번째 선행 항목은 x가 Comet에 바인딩되어 있는 경우 y에 대해 두 가지 가능한 바인딩으로 이어집니다.

-이제 x에 대한 바인딩이 있고 변수가 바인딩으로 대체될 때 각 선행 항목이 주장에 해당하도록 y에 대한 바인딩이 있는 경우 규칙은 
x에 바인딩된 것이 가치 있다는 결론을 정당화합니다. 예를 들어, x가 Comet에 바인딩되고 y가 Prancer에 바인딩되면 각 antecedent 항목은 
assertion에 해당합니다. 즉 Comet은 말, Comet은 Prancer의 부모, Prancer는 빠릅니다. 따라서 Comet은 가치가 있어야 합니다.

-바인딩 쌍 검색을 수행하려면 각 assertion에 대해 첫 번째 antecedetn 항목을 일치시키는 것으로 시작할 수 있습니다. 
그림 7.4에서 볼 수 있듯이 Comet, Prancer, Thunder 및 Dasher는 모두 말이기 때문에 antecedent ?x is-a horse에서 x에 대해 
4개의 일치와 4개의 해당 바인딩 선택이  있습니다.

-다음으로 깊이 우선 검색 스타일로 진행하면서 x의 바인딩이 첫 번째 일치에 의해 생성된 바인딩인 Comet이어야 한다고 가정합니다. 
그런 다음 x가 Comet에 묶인 상태에서 인스턴스화 후 두 번째 주장은 Comet이 y의 부모입니다. Comet이 Dasher와 Prancer의 부모이기 
때문에 각 주장에 대해 이 두 번째 인스턴스화된 antecedent 항목을 일치시키면 두 개의 일치 항목이 생성됩니다. 따라서 x가 Comet에 
바인딩되어 있는 경우 y에 대해 두 가지 바인딩 선택이 있습니다.

-그림 7.4는 x와 y 선택이 어떻게 함께 들어맞는지 보여줍니다. 명백하게, 지금까지 조사된 두 개의 antecedent 사례 각각은 검색 트리에 
배열될 수 있는 바인딩 선택을 생성합니다.

-x가 Comet에 묶이고 y가 Dasher에 묶인 가장 왼쪽 가지를 따라 여행하면 y의 binding으로 인스턴스화할 때 Dasher is fast.
그러나 이 인스턴스화된 antecedent 항목은 어떤 assertion과도 일치하지 않으므로 허용 가능한 조합을 더 멀리 찾아야 합니다. 
이전과 같이  Comet에 바인딩된 x와 Prancer에 바인딩된 y의 조합은 Prancer가 빠르기 때문에 주장과 일치하는 세 번째 전건의 인스턴스화로 
이어지기 때문에 멀리 볼 필요가 없습니다. 따라서 Comet에 묶인 x와 Prancer에 묶인 y의 조합은 모든 antecedent 장애물을 뛰어 넘는 
조합이라는 결론을 내릴 수 있습니다. 이 조합을 사용하여 결과를 인스턴스화할 수 있으며 Comet을 생성하는 것은 가치가 있습니다.

-그림 7.4에서 볼 수 있듯이 x 바인딩에는 세 가지 다른 선택이 있습니다. 이 중 x가 Prancer 또는 Thunder에 바인딩되어 있으면 
두 번째 주장이 일단 인스턴스화되면 Prancer is-a-parent-of y 또는 Thunder is-a-parent-of y가 됩니다. 둘 다 어떤 주장과도 
일치하지 않습니다. Dasher가 적절한 바인딩이면 Dasher는 y의 부모인 단 하나의 assertion과 일치하고 Dasher is a-parent-of Thunder.
y의 바인딩에 대한 선택 항목으로 Thunder만 남습니다. x가 Dasher에 바인딩되고 y가 Thunder에 바인딩되어 있을 때 
세 번째 인스턴스화된 선행 조건은 Thunder is fast이며 이는 주장과 일치하여 그림 7.5에서 볼 수 있듯이 Dasher-Thunder 조합도 
모든 장애물을 뛰어넘는다는 결론에 이르게 합니다. Dasher도 가치가 있습니다.-
-그림 7.5 두 개의 경로는 루트에서 세 가지 규칙 선행 항목에 해당하는 수준까지 확장됩니다. 분명히 규칙을 충족하는 
두 개의 바인딩 집합이 있습니다.

-이 예에서 몇 가지 관심 사항이 나타납니다. 먼저 검색 트리의 각 경로가 바인딩된 commitment에 해당한다는 것을 알 수 있습니다. 
둘째, 각 antecedent 항목은 경로를 따라 이미 누적된 바인딩이 주어지면 0개 이상의 assertion과 일치하고 각 성공적인 일치는 분기를 생성합니다. 
셋째, 탐색 트리의 깊이는 항상 antecedent 항목의 수와 같습니다. 넷째, 평소와 같이 트리를 검색하는 방법을 선택할 수 있습니다. 
철저한 깊이 우선 왼쪽에서 오른쪽 검색은 규칙을 배포할 수 있는 모든 가능한 방법을 찾는 것이 목적일 때 일반적인 방법입니다. 
이 방법은 다음 절차에 표시된 방법입니다.

To forward chain (detailed version),
> Until no rule produces a new assertion,
> For each rule,

> Try to match the ﬁrst antecedent with an existing assertion Create a new binding set with variable bindings established 
by the match.

> Using the existing variable bindings, try to match the next antecedent with an existing assertion. If any new variables 
appear in this antecedent, augment the existing variable bindings.

> Repeat the previous step for each antecedent, accumulating variable bindings as you go, until.

> There is no match with any existing assertion using the binding set established so far. In this case, back up to a previous 
match of an antecedent to an assertion, looking for an alternative match that produces an alternative, workable binding set.

> There are no more antecedents to be matched. In this case,

> Use the binding set in hand to instantiate the consequent.

> Determine if the instantiated consequent is already asserted. If not, assert it.

> Back up to the most recent match with unexplored bindings, looking for an alternative match that produces a workable 
binding set.

> There are no more alternatives matches to be explored at any level.

Depth-First Search Can Supply Compatible Bindings for Backward Chaining

-Forward Chaining은 각 집합에 대해 변수가 집합의 바인딩으로 대체되면 모든 antecedent 항목이 assertion에 해당하도록 변수 바인딩 집합을 
검색하는 것으로 볼 수 있다는 것을 배웠습니다.

-Backward Chaining은 동일한 일반적인 방식으로 처리될 수 있지만 몇 가지 중요한 차이점과 복잡성이 있습니다. 특히 기존 assertion과 
규칙 결과에 대해 가설을 일치시키는 것으로 시작합니다.

-예를 들어, working memory에서 이전과 동일한 규칙과 assertion을 사용하여 여전히 horse를 사용하여 작업하고 있다고 가정합니다. 
다음으로 Comet이 가치가 있다는 것을 보여주고 싶다고 가정합니다. 즉, Comet은 가치가 있다는 가설을 확인하려고 한다고 가정합니다. 
Comet과 일치하는 항목을 찾는 데 실패하면 assertion 중에서 가치가 있지만 가설을 결과 규칙인 ?x가 가치 있는 것과 일치시키는 데 
성공합니다. 성공하면 x가 Comet에 묶여 있다고 가정하고 antecedent 조건을 일치시키려고 합니다.

-다행히도, 인스턴스화된 첫 번째 선행 항목인 Comet is-a horse가 assertion과 일치하여 인스턴스화된 두 번째 antecedent 항목인 
Comet is-a-parent-of y를 검색할 수 있습니다. 이 두 번째 antecedent 조건은 두 개의 일치로 이어집니다. 하나는 Comet is-a-parent-of Dasher
주장과 다른 하나의 assertion은 Comet is-a-parent of Prancer가 있습니다. 따라서 그림 7.6과 같이 검색 분기가 이루어집니다.

-왼쪽 가지를 따라 y는 Dasher에 바인딩되어 세 번째 선행 Dasher를 assertion에 빠르게 일치하도록 하는 헛된 시도로 이어집니다. 
그러나 오른쪽 분기를 따라 y는 Prancer에 바인딩되어 있어 Prancer와 일치시키려는 시도가 빠르게 assertion에 연결됩니다.

-분명히 Comet이 가치가 있다는 가설은 검색에 의해 발견된 바인딩 세트가 규칙을 통해 가설을 assertion과 연결하기 때문에 
주어진 규칙과 주어진 주장의 조합에 의해 뒷받침됩니다.

-그러나 가설 자체에 변수가 포함되어 있으면 검색이 더 복잡해집니다. 질문이 "누가 가치 있는가?"라고 가정해 보겠습니다. "Comet은 
가치가 있습니까?"보다 그런 다음 가설 자체인 ?z는 가치가 있으며 변수 z를 포함합니다.

-이 새로운 가설은 Comet이 가치가 있다는 가설과 마찬가지로 어떤 주장에도 일치하지 않지만 결과와 일치하는 ?x는 가치가 있습니다. 
그러나 이제 상수 Comet과 변수 x 대신 두 변수 z와 x 사이에 일치 항목이 있습니다.

-따라서 이제 첫 번째 antecedent를 주장과 일치시킬 때이므로 z가 x에 바인딩된 일치에 들어갑니다. 그러나 변수 x는 아무 것도 구속되지 
않으므로 첫 번째 antecedent 항목의 일치는 마치 연쇄가 앞으로 진행되는 것처럼 제한 없이 진행됩니다. 주장에 대한 첫 번째 antecedent의 가능한 
일치가 네 가지 있으며 x는 Comet, Prancer, Thunder 또는 Dasher 중 하나에 바인딩됩니다. 그런 다음 x의 바인딩이 Comet이어야 하고 
다음 두 주장이 허용하는 바인딩을 통해 작업하면 z가 x에 바인딩되고 x가 Comet에 바인딩되고 y가 Prancer에 바인딩되는 
그림 7.7에 표시된 결과 중 하나로 이어집니다. 

-가설의 변수인 z가 규칙의 변수인 x와 일치한다는 사실 심각한 일시 중지가 필요하지 않습니다. 수행해야 하는 유일한 추가 작업은 
인스턴스화를 계속할 수 있는 옵션이 있을 때마다 상수로 인스턴스화하는 것입니다. 따라서 먼저 z를 x로 대체한 다음 x를 Comet으로 
대체하여 Comet에 대한 인스턴스화된 가설을 생성하는 것이 중요합니다.

-그림 7.6 forward chaining과 마찬가지로 backward chaining동안 바인딩 커밋은 트리에 정렬될 수 있지만 첫 번째 바인딩 커밋은 
결과에 의해 설정됩니다. 첫 번째 antecedent보다 여기서 결과는 x에 대해 하나의 바인딩을 설정하고 두 번째 선행은 y에 대해 
두 개의 바인딩을 설정합니다. x에 대한 바인딩과 y에 대한 두 바인딩 중 하나는 Comet이 가치가 있음을 설정합니다.

-이 시점에서 원한다면 다른 귀중한 말을 찾기 위해 변수를 묶는 다른 방법을 계속 찾을 수 있습니다.

-둘 이상의 규칙이 변수 바인딩을 제공할 수 있는 경우 검색은 훨씬 더 복잡합니다. 예를 들어, 변수 ?z가 가치 있는 가설이 있지만 
이제 새 규칙과 두 개의 새 주장을 추가한다고 가정합니다.
//
Winner Rule
If 	?w is-a winner
then 	?w is fast
 
Dasher 	Is-a Winner
Prancer 	Is-a Winner

-그림 7.7 역방향 연결 동안 가설 변수는 assertion 상수뿐만 아니라 consequent vaiable에도 연결될 수 있습니다. 여기에서 가설 변수 z는 결과 
변수 x에 바인딩됩니다. 궁극적으로 두 개의 바인딩 세트가 발견되어 두 마리의 말이 가치가 있음을 확인합니다.

-이제 검색은 그림 7.8과 같이 이전과 같이 세 번째 antecedent 조건에 일치하는 항목을 찾을 때까지 진행됩니다. ?y는 빠릅니다. 
처음에는 y가 Dasher에 바인딩되어 일치하는 assertion이 없지만 두 번째 규칙의 결과 w is fastdhk  인스턴스화된 첫 번째 규칙 선행 항목인 
Dasher is fast에 일치가 있습니다. 결과적으로 w는 Dasher에 바인딩되고 두 번째 규칙의 인스턴스화된 antecedent 조건인 
Dasher는 주장에 대해 승자 간의 일치를 찾기 위해 노력합니다. 두 개의 새로운 주장 중 하나와 일치하는 항목이 있기 때문에 
Dasher가 실제로 빠르다는 결론을 내릴 수 있습니다. 즉, 원래 가설인 ?z가 가치가 있으며 w 및 y가 바인딩된 바인딩 집합을 
사용하여 규칙을 통해 주장에 연결할 수 있습니다. Dasher에 x는 Comet에 z는 x에 바인딩됩니다. 이 바인딩 세트로 가설을 
인스턴스화하려면 먼저 z를 x로 바꾼 다음 x를 Comet으로 바꿉니다.

-그림 7.8 backward chaining 연결 동안 규칙은 하나의 antecedent가 다른 것의 consequent와 일치할 때마다 함께 연결됩니다. 
여기서 antecednet ?y is fast, 한 규칙에서 consequent와 일치합니다. ?w is fast는 다른 규칙입니다.

-Comet은 가치가 있다는 궁극적인 결론에 이미 도달했기 때문에 인스턴스화된 antecedent항목인 Comet은 y의 부모입니다. 그럼에도 불구하고 
대부분의 바인딩 세트 프로그램은 아무 것도 얻을 수 없다는 것을 인식할 만큼 똑똑하지 않으므로 Comet-is-a-parent-of-y를 사용하여 
y를 바인딩하는 다른 방법을 찾습니다.

-그림 7.8에서 볼 수 있듯이 y는 Prancer에 바인딩될 수 있으며 이는 세 번째 antecedent 조건과 일치시키려는 시도로 이어집니다. 
Prancer는 assertion으로 빠릅니다. 매치는 성공하고 다른 바인딩 세트로 Comet이 가치가 있음을 재확인합니다.

-훨씬 더 많은 에너지를 표시하면서 대부분의 바인딩 프로그램은 인스턴스화된 선행 항목인 Prancer is fast가 데이터베이스에 있다는 점에 주목합니다. 
그들은 또한 그림 7.8에서 볼 수 있듯이 Prancer is fast를 주장 Prancer is-a Winner에 연결하는 규칙이 있으므로 w에 대한 바인딩을 
포함하는 바인딩 집합으로 세 번째로 Comet 가치가 있습니다.

-유사하게, Dasher가 가치 있다는 증거를 검색할 때, 인스턴스화된 antecedent Thunder is fast는 assertion과 일치할 뿐만 아니라 
두 번째 규칙에서 결과 w is fast와 일치합니다. 그러나 이번에는 w is-winner에 대한 두 번째 규칙의 인스턴스화된 antecedent 항목이 
어떤 주장과도 일치하지 않으므로 Dasher가 가치 있음을 보여주는 한 가지 방법만 남아 있습니다.

-요약하면, backward chaining 절차는 초기 가설에서 규칙을 통해 알려진 사실로 이동하여 프로세스에서 변수 바인딩을 설정합니다. 
초기 가설이 규칙의 결과와 일치하면 바인딩 집합을 만듭니다. backward chaining 절차가 antecedent 항목에 대해 작동할 때 
초기 바인딩 집합에 추가 바인딩이 추가되고 절차가 antecedent 항목을 통해 다른 규칙의 결과로 연결될 때 더 많은 바인딩이 추가됩니다. 다음 절차는 
다음과 같이 요약됩니다: 

To backward chain,
> Find a rule whose consequent matches the hypothesis (or antecedent) and create a binding set (or augment the existing
binding set).

> Using the existing binding set, look for a way to deal with the ﬁrst antecedent,

> Try to match the antecedent with an existing assertion.

> Treat the antecedent as an hypotheses and try to support it by backward chaining through other rules using the 
existing binding set.

> Repeat the previous step for each antecedent, accumulating variable bindings, until,

> There is no match with any existing assertion or rule cosequent using the binding set established so far. In this
case, back up to the most recent match with unexplored bindings, looking for an alternative match that produces
a workable binding set.

> There are no more antecedents to be matched. In this case, the binding set in hand supports the original hypothesis.

> If all possible binding sets are desired, report the current binding set, and back up, as if there were no match.

> If only one possible binding set is desired, report the current binding set and quit.

> There are no more alternative matches to be explored at any level.

Rolatlonal Oporatlom Support Forward Chaining
-이제 Forward Chaining에 대한 또 다른 접근 방식을 살펴볼 때입니다. 먼저 관계형 데이터베이스 작업이 순방향 연결에 필요한 부기를 
처리하는 방법을 배웁니다. 그런 다음 관계형 데이터베이스 작업을 배열하여 고속 작업을 생성하는 방법을 배웁니다.

-이 섹션에서는 관계형 데이터베이스에 대해 알아야 할 모든 내용을 필요할 때 소개합니다. 다른 곳에서 관계형 데이터베이스를 
연구한 적이 없고 이 섹션의 소개가 너무 짧다고 생각되면 관계형 데이터베이스에 대해 자세히 설명하는 부록을 읽으십시오.

-이제 이전에 검색 지향 접근 방식을 시연하는 데 사용된 상위 규칙 및 주장을 고려하십시오. 여기에 다시 부모 규칙이 있습니다.

Parent Rule
If	?x is-a horse
	?x is-a-parent-of ?y
	?y is fast
then 	?x is valuable

-이제 assertion이 테이블의 일부인 것처럼 생각하십시오. 관계의 언어에서 주장은 Data라는 관계에 기록되며, 열(column)에는 
First, Second 및 Third와 같이 필드 이름이 레이블이 지정됩니다:

Fist		Second		Third
Comet		is-a		horse
Prancer		is-a		horse
Comet		is-a-parent-of	Dasher
Comet		is-a-parent-of	Prancer
Prancer		is		fast
Dasher		is-a-parent-of	Thunder
Thunder		is		fast
Thunder		is-a		horse
Dasher		is-a		horse

-규칙을 트리거하는 x 및 y 값을 결정하려면 먼저 관계의 레코드 중 규칙의 첫 번째 항목과 일치하는 ?x가 말인지 결정합니다. 
관계의 언어에서 두 번째 필드 값이 is-a이고 세 번째 필드 값이 말인 레코드를 찾아야 합니다. 편리하게도 관계형 데이터베이스 
시스템에는 하나의 관계에서 지정된 필드 값이 있는 레코드를 추출하여 더 적은 수의 레코드로 새 관계를 생성하는 액세스 절차인 
SELECT가 포함됩니다. 데이터 관계에서 말을 선택하도록 SELECT에 요청할 수 있습니다. 예를 들면 다음과 같습니다:

The result is the new relation:
First		Second		Third
Comet		is-a		horse
Prancer		is-a		horse
Thunder		is-a		horse
Dasher		is-a		horse


-그러나 정말로 알고 싶은 것은 x의 어떤 바인딩이 일치하는지입니다. 따라서 다른 관계형 데이터베이스 액세스 프로시저인 
PROJECT를 사용하여 적절한 필드를 분리합니다:

-PROJECT Result over First 

-이 시점에서 First라는 필드는 x 변수에 대한 바인딩으로 구성되어 있음을 상기시키기 위해 X로 이름이 바뀝니다. 
단일 필드 관계인 결과는 다음과 같습니다:

A1	X
	Comet
	Prancer
	Thunder
	Dasher

-다음으로 데이터 관계의 레코드 중 ?x가 ?y의 상위 항목인 규칙의 두 번째 선행 항목과 일치하는지 확인합니다. 두 번째 필드 값이 
is-a-panent-of인 레코드를 선택해야 합니다. 그런 다음 첫 번째 및 세 번째 필드에 대한 결과를 투영합니다.

PROJECT		[SELECT Data with Second = is-a-parent-of]
		over First and Third

-First라는 필드의 이름을 X로, Third라는 필드의 이름을 Y로 변경하면 다음 테이블이 생성됩니다:

A2	X	Y
	Comet	Dasher
	Comet	Prancer
	Dasher	Thunder

-마지막으로 데이터 관계의 어떤 레코드가 규칙의 세 번째 선행 항목과 일치하는지 확인해야 합니다. ?y는 빠릅니다. 따라서 두 번째 
필드 값이 'is'이고 세 번째 필드 값이 빠른 레코드를 선택하고 첫 번째 필드에 결과를 투영합니다:

PROJECT		[SELECT Data with Second = is and Third = fast]
		over First

-First라는 필드의 이름을 Y로 바꾸고 필드 값이 y에 대한 가능한 바인딩이라는 사실을 반영하면 다음 테이블이 생성됩니다:

A3	Y
	Prancer
	Thunder

-이제 규칙의 세 가지 선행 조건에 해당하는 세 개의 새 관계(A1, A2 및 A3)가 있습니다. 다음 질문은 x의 어떤 바인딩이 첫 번째와 
두 번째 선행 조건을 모두 충족합니까? 또는 A1의 X 필드와 A2의 X 필드 모두에서 어떤 필드 값을 찾을 수 있습니까?

-JOIN 작업은 레코드가 지정된 필드에서 일치하도록 두 소스 테이블 각각에서 하나씩 레코드를 연결하여 구성된 레코드와 관계를 
구축합니다. 따라서 X 필드에 대해 A1과 A2를 결합하여 공유되는 x 값을 결정할 수 있습니다. 필요한 JOIN 작업은 다음과 같습니다.

JOIN A1 and A2 with X = X

-결과는 모호한 필드 이름을 기여하는 관계의 이름과 연결하여 필드 이름 모호성이 제거되는 관계입니다:

B1(preliminary)	X.A1		X.A2		Y
		Comet		Comet		Dasher
		Comet		Comet		Prancer
		Dasher		Dasher		Thunder

-물론 여러분이 정말로 원하는 것은 처음 두 개의 선행 조건을 충족하는 x와 y에 대한 결합 쌍을 찾는 것입니다. 따라서 필드 이름을 
바꾼 후 X.A1 및 Y에 대한 예비 B1 관계를 투영할 수 있으며 다음과 같은 결과를 얻을 수 있습니다:

B1	X	Y
	Comet	Dasher
	Comet	Prancer
	Dasher	Thunder
 
-이제 B1에는 규칙의 처음 두 가지 선행 조건을 동시에 충족하는 바인딩 쌍이 포함됩니다. 이제 분석을 반복하여 이러한 결합 쌍 중 세 번째 
선행 조건도 충족하는 쌍을 확인할 수 있습니다.

-Tb 시작, Y 필드에 대해 A3 및 B1을 결합하여 y의 윈치 값이 공유되는지 확인합니다:

JOIN A3 and B1 with Y = Y

The result is as follows:

B2(Preliminary)	Y.A3		X		Y.B1
		Prancer		Comet		Prancer
		Thunder		Dasher		Thunder

-이제 처음 두 개의 선행 조건뿐만 아니라 세 번째 조건도 충족하는 x 및 y에 대한 결합 쌍을 결정하도록 계획합니다:

B2	X	Y
	Comet	Prancer
	Dasher	Thunder

-이 시점에서 세 가지 전제 조건을 동시에 충족하는 두 개의 바인딩 쌍이 있음을 알 수 있습니다. 규칙의 then 부분은 x의 
바인딩만 사용하므로 X 필드에 B2를 투영합니다:

B2	X
	Comet
	Dasher

-따라서 상위 규칙은 두 가지 방법으로 트리거됩니다. x가 Comet에 바인딩된 경우 한 번, x가 있는 경우 Dasher에 바인딩된 경우,
연역 시스템에서는 두 바인딩 세트를 모두 사용할 수 있습니다. 반응 시스템에서 다음 조치를 선택하려면 갈등 해결 절차가 필요합니다.

-방금 배운 절차의 유일한 문제는 많은 양의 계산을 소비한다는 것입니다. 규칙에 n개의 선행 항목이 있는 경우 B 관계를 생성하는 
n-1 JOIN 및 n-1 PROJECT 작업과 함께 A 관계를 생성하기 위해 n SELECT 및 n PROJECT 작업이 필요합니다. m개의 규칙이 있고 
데이터 관계에 새 주장이 추가될 때마다 각 규칙을 체크아웃하면 mn SELECT, m(2n-1) PROJECTS를 수행해야 합니다. 그리고 가장 
놀라운 것은 새로운 주장이 추가될 때마다 m(n-1)개의 값비싼 JOIN입니다. 다행히 많은 연산을 사용하지 않는 변수 바인딩을 검색하는 
또 다른 방법이 있습니다.

-관계형 Oparation을 점진적으로 배포하는 Rota 접근 방식 바인딩 집합을 찾기 위해 관계형 작업을 사용하는 방법을 배웠지만 규칙을 
트리거하려면 많은 작업을 수행해야 하기 때문에 설명된 방법은 순방향 연결을 수행하는 데 비용이 많이 드는 방법입니다. 
이제 각각의 새로운 어설션이 만들어질 때마다 관계형 작업을 점진적으로 수행할 수 있으므로 트리거하는 모든 어설션이 준비되면 
총 작업량과 규칙을 트리거하는 데 걸리는 시간을 모두 줄일 수 있습니다.

-일반적으로 rete라는 단어는 큰 사전에서만 발견되는 net의 모호한 동의어입니다. 그러나 순방향 연결의 맥락에서 rete 절차라는 
단어는 관계형 레코드로 간주되는 각각의 새로운 주장을 하나의 관계 또는 몇 개의 , 그러나 누적된 주장을 나타내는 모든 관계에는 
적용되지 않습니다.

-The arrangement of the rete for the valuable-horse example is Shown in ﬁgure 7.9.

-새로운 주장이 만들어지면 단일 레코드 관계가 됩니다. 그런 다음 해당 단일 레코드 관계는 SELECT 작업 패밀리에 의해 검사되며, 
각 작업은 규칙 선행 항목에 해당합니다.

-이 예에서 첫 번째 주장은 Comet is-horse입니다. 따라서 다음과 같은 단일 레코드 관계가 구성됩니다

New-assertion	First	Second	Third
		Comet	is-a	horse

This relation is examined by three SELECT operations:

SELECT new-assertion with Second = is-a and Third = horse
SELECT new-assertion with Second = is-a-parent-of
SELECT new-assertion with Second = is and Third = fast

-다음으로 단일 레코드 관계의 레코드가 SELECT 작업을 통과할 때마다 단일 레코드 관계는 바인딩을 포함하는 필드를 선택하는 
PROJECT 작업을 견뎌냅니다.

-그림 7.9 빠른 자손을 가진 말에 대한 간단한 규칙에 대한 rete. 여기에서 rete의 상태는 주장에 대한 응답으로 추가된 직후 캡처됩니다. 
이 그림과 다른 그림에서 가장 최근의 변경 사항은 음영으로 표시됩니다.

-이 예에서 레코드는 세 가지 SELECT 작업 중 첫 번째 작업을 통과하고 PROJECT 및 이름 바꾸기 작업은 다음을 생성합니다.

New-assertion	X
		Comet

-레코드가 SELECT, PROJECT 및 이름 바꾸기 작업을 지나면 규칙 선행 항목과 연결된 관계에 추가됩니다. 각 선행 항목 특정 관계는 
선행 항목을 위해 특별히 생성된 알파 노드에 있습니다. 각 알파 노드 관계는 필터와 같은 해당 SELECT 작업을 통해 만드는 
모든 어설션을 누적합니다. 예에서, 선택되고, 예상되고, 이름이 변경된 레코드는 첫 번째 선행 항목에 연결된 A1 노드에 추가됩니다.

-두 번째 주장인 Prancer is-a Horse는 첫 번째 주장을 따라가며 A1node에 연결된 관계의 레코드로 끝납니다. 그런 다음 세 번째 주장인 
Comet is-a parent-of Dasher는 다른 경로를 따라 A2 노드에 연결된 관계의 레코드로 끝납니다.

-알파 노드의 관계에 추가될 때마다 단일 레코드 관계로 간주되는 추가된 레코드를 다른 관계와 결합하려는 시도가 발생합니다. 특히 
A1의 관계 또는 A2의 관계에 추가하면 단일 레코드 관계로 간주되는 추가된 레코드가 다른 알파 노드에 연결된 관계와 결합됩니다. 
중요하게, JOIN 작업은 추가된 레코드에 표현된 변수 바인딩이 다른 관계에서 이미 설정된 변수 바인딩에 해당하는지 여부를 결정하기 
위한 관점에서 수행됩니다.

-예에서 A2의 관계에 추가된 레코드는 다음과 같은 단일 레코드 관계를 생성합니다.

X	Y
Comet	Dasher

Meanwhile, A1’s relation has accumulated two records:

A1	X
	Comet
	Prancer
 
Joining the two relations over the X ﬁeld and projecting to eliminate one
of the redundant X ﬁelds yields a one-record, two-ﬁeld relation:

X	Y
Comet	dasher

-그런 다음 이 새 관계는 A1 및 A2 관계의 JOIN이기 때문에 명명된 베타 노드인 B12 노드에 연결된 관계에 추가됩니다. B12의 관계는 
첫 번째 및 두 번째 선행 조건을 충족하는 x 및 y에 대한 바인딩 쌍을 기록하는 단일 레코드를 포함합니다.

-따라서 A1의 관계 또는 A2의 관계에 추가하면 처음 두 규칙 선행 조건을 동시에 충족하는 변수 바인딩을 반영하는 B12의 관계에 하나 
이상의 레코드를 추가할 수 있는 JOIN 작업이 발생합니다.

-다음 주장인 네 번째 혜성은 Prancer의 부모이며 그림 7.10의 음영으로 표시되는 망사에서 활동의 파동을 생성합니다.

-웨이브는 A2의 관계에 두 번째 레코드를 추가하는 것으로 시작됩니다. 단일 레코드 관계로 간주되는 이 새 레코드는 A1의 관계에 결합되어 
B12의 관계에 대한 두 번째 레코드를 생성합니다.

-관계로 본 레코드가 다른 릴레이션과 결합될 때마다 관계로 본다는 표현을 덧붙이는 것은 번거롭기 때문에 엄밀히 말하면 관계로만 보더라도 
레코드를 관계로 결합하는 것에 동의하자, 가입됩니다.

-다음으로, 다섯 번째 주장인 Prancer is fast는 rete의 레코드에 대한 추가 물결을 시작하고 A3의 관계에 있는 레코드로 이어집니다. 
일반적으로 A3의 관계에 추가하면 추가된 레코드를 B12의 관계와 결합하게 됩니다. 이 JOIN 작업은 추가된 레코드에 표현된 변수 
바인딩이 B12의 관계에 이미 설정된 변수 바인딩에 해당하는지 여부를 확인하기 위해 수행됩니다.

-결과는 B23의 관계에 추가됩니다. 이 예에서 JOIN 연산은 Y 필드에 대해 수행되고 JOIN 연산은 중복 Y 필드 중 하나를 제거하기 
위해 PROJECT를 수행한 후 B23의 관계에 대한 초기 레코드를 생성합니다.

B23	X	Y
	Comet	Prancer

Projecting this new record over the X ﬁeld yields a possible binding for x
in the rule’s then part:

Parent-Rule Bindings B23	X
			Comet

-그림 7.10 여기에서 속도 상태는 네 번째 주장인 Comet is-a-parent of Prancer에 대한 응답으로 추가된 내용을 캡처한 것입니다. 
추가 사항은 음영 처리되어 표시됩니다.

-따라서 A3의 관계에 추가로 B12의 관계와 추가 기록에 합류하게되었습니다. 물론 대칭적으로 B12의 관계에 추가된 모든 새 레코드는 
A3의 관계에 조인됩니다. 이전과 마찬가지로 JOIN 연산은 추가된 레코드에 표현된 avriable 바인딩이 JOIN 연산에 포함된 다른 관계에서 
이미 표현된 변수 바인딩에 해당하는지 확인하기 위해 수행됩니다.

-이제 Dasher는 Thunder의 부모이고, Thunder는 빠르며, Thunder는 말이라는 세 가지 어설션을 추가한 후 속도의 상태를 고려하십시오. 
A1의 관계는 3마리의 말이 있음을 나타냅니다.

A1	X
	Comet
	Prancer
	Thunder

A2’s relation indicates that Comet is a parent of two children, and Dasher
is a parent of one child:

A2	X	Y
	Comet	Dasher
	Comet	Prancer
	Dasher	Thunder

A3's relation indicates that Prancer and Thunder are fast:

A3	Y
	Prancer
	Thunder
 
Next, the information in the alpha-node relations is joined to form the
beta-node relations:

B12	X	Y
	Comet	Dasher
	Comet	Prancer

B23	X	Y
	Comet	Prancer

-다음으로, 아홉 번째 주장인 Dasher is-a horse는 그림 7.11에서 음영으로 표시된 추가 비율로 레코드에 추가의 또 다른 물결을 시작합니다.

-이러한 추가 사항 중 첫 번째는 A1의 관계에서 새로운 기록입니다. 이 새 레코드는 A2의 관계에 결합되어 B12의 관계에 새 레코드를 생성합니다.

B12(increment)	X	Y
		Dasher	Thunder

But now this new B12 record is joined to A3‘s relation producing a new
record for B23‘s relation: 

B23(increment)	X	Y
		Dasher	Thunder

Projection of this new record over the X ﬁeld yields another possible binding
for x in the rule’s consequent: 

Parent-Rule Bindings (increment) B23	X
				Dasher

Thus, after all nine assertions are processed, the possible bindings for x in
the rule‘s consequent are given by the following relation: 

Parent-Rule Bindings B23	X
			Comet
			Dasher

-이미 보았듯이 새 관계를 추가하면 JOIN 작업이 새 레코드를 생성하는 한 rete를 통해 계속되는 물결 모양 현상이 생성됩니다. 
모든 관계형 작업에는 몇 가지 주장을 포함하는 소규모 관계만 포함됩니다. 그들은 결코 전체 축적된 주장 데이터베이스를 포함하지 
않습니다

-7.11 여기에서 rete의 상태는 9번째 주장인 Dasher is-a horse에 대한 응답으로 추가된 직후 캡처됩니다. 가장 최근의 변경 사항이 
음영 처리되어 표시됩니다.

-예제가 복잡해 보일 수 있지만 rete를 만들고 사용하는 절차는 간단합니다.

To construct a rete,

> For each antecedent pattern that appears in the rule set, create a SELECT operation that examines new assertions.

> For each rule,
> For each antecedent,
> Create an alpha node and attach it to the corresponding SELECT operation, already created. 
> For each alpha node, except the ﬁrst, 
> Create a beta node.
> If the beta node is the ﬁrst beta node, attach it to the ﬁrst and second alpha nodes.
> Otherwise, attach the beta node to the corresponding alpha node and to the previous beta node.
> Attach a PROJECT operation to the ﬁnal beta node.

To use a rete,
> For each assertion, ﬁlter the assertion through the SELECT operations, passing the assertion along the rete to the appropriate alpha nodes.

> For each alpha node receiving an assertion, use the PROJECT operation to isolate the appropriate variable bindings. Pass these new bindings, 
if any, along the rete to the appropriate beta nodes.
> For each beta node receiving new variable bindings on one of its inputs, use the JOIN operation to create new variable binding sets. Pass these new variable binding
sets, it any, along the rete to the next beta node or to the ﬁnal PROJECT operation.
> For each rule, use the PROJECT operation to isolate the variable bindings needed to instantiate the consequent.

















































  

























