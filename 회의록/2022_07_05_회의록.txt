현재 노드 별로 정리한것이라면
CoS 노드랑 Forwading node에 공격이 동시에 발생할 경우 
CoS에서의 현상으로도 설명할 수 있지만, CoS에서 일이 발생하고 나서 이후에 Forwarding 노드에서는 이런 일이 있더라라는 
이런 현상이 있더라고 생각해 볼것!!
여러개의 Timing diagram을 생각해 볼것!!
시간이 다를 수도 있고 같을 수도 있음. 
그런 경우도 아마 찾을 수 있을 것임. 지금의 경우가 어떤 한 노드에서 수집할 수 있는 내용+이런 일이 발생된 이후에 
다른 노드에서 이런일이 있으면 더 확실하다.
CoS에서 Compromise 되었을 때랑 안되었을 때랑은 확실히 같다고 할 수 없음.
다른 점을 찾을 수 있다면 동시에 공격의 현상으로 사용하면 정확도가 높음!!
시간과 공간을 한정짓지 말고 시간과 공간의 범위를 높여서 확인 할것!!
정리한것처럼 개별적인 현상을 정확하게 분석을 해서 하는 것이 일단 중요함!!
이렇게 해놓으면 더 쉽게 생각 할 수 있음!!
Forwarding node도 다음 Forwarding node로 전달 될 때 다음 노드 다음 다음 노드의 현상이 똑같다?조금이라도 다르면
사용하면 좋을 것 같다!!
연구의 범위를 생각한다면 Compromise를 탐지하는 것!!이게 제일 어려움!! 
security protocol만 가지고 해결하는 것은 거의 불가능 한 것임!
그래서 그것 + 다른 지능적인 내용을 적용하는 것임!!
또한가지는 그냥 공간적인 값만으로는 찾기 어려움!! 지금 더 좋은 것은 시간이 늘어난다 + 늘어나는 시간에 어떠한 변화가 있는가
(공간값)이전에는 어떤 현상인데 이런것이 발생할 수 있다. Compromise의 증거를 찾는 것!
시간이 늘어났다 => 그러면 공격이다 라고 단정 지어도 되는가?

키 복제의 부분에서 주변에 있는 것 다 복제한다고 해서 원한는 키를 다 복제 할 수 있나? 그건 아님!! 공격의 효울을 
높이려면 상당히 많은 곳에서 실시간으로 가져와서 복제를 한다는 개념임
교수님이 공격자라면 과연 그런식으로 할까?=>너무 오래걸리고, 번거로운 작업인것같다.
일정 power의 device에 모아놨다가 새로운 메시지에 대한 것에 거기에서 찾아서 복제를 한다.
=>같은 방법이지만 훨씬 덜 복잡함
Compromise 된 노드에 복제가 필요할까?라는 부분에 대해 생각해 봐야할 것임.
저기다가 Copy를 해놓아야 할까? 중간에 메시지를 보고 가져와서 해야하니깐 그런 통신에 대한 부담이 있고
에너지가 많이 사용되니깐 복제가 더 편하긴 한데 노드에 메모리가 가능한가에 대한 생각도 해봐야함
만약 한정적인 메모리를 사용한다면 공격자의 device에서 갖고 온다면 power에 대한 부분에 따라 걸리는 시간이 다른 것임!!

시간을 고려한다고 해서 시간이 늘어나고 줄어드는 것에 대한 부분 뿐만 아니라 어느 특정 시간에 어떤 일을 하는 것에 대한 부분을
생각하는 것이 중요함

특정 노드에서 일어나는 정보를 탐지하는 
history trajectory도 사용하고 현재 Trajectory도 사용함 그럼 과거의 Trajectory와 비교하기 때문에 knowledge가 있고
특정 device에서 일어나는 것을 탐지

정상 Trajectory를 두고 정상에서 벗어낫나? 그걸 확인하는것!=>정원진 선배님
현재 Trajectory와 과거 Trajectory를 모두 사용해서 탐지하는데 특정 공격을 사용함=>안정섭 선배님

군인이 적이 접근하는 것을 탐지하기 위해서는 이상점을 발견하고, 확실히 알아봐 공격이다 아니다가 판별되면
공격을 어떻게 할지를 생각하는 것(이상 Trajectory를 사용)해서 정확하게 탐지 해내는 것!!

처음에는 정상 Trajectory를 기준으로 거기서 벗어났나를 확인하는 것이 1차 적으로 해야할 일이고, 이후에 공격 Trajectory를
활용하여 정확하게 탐지할 수 있도록 하는 것!

아까 정상하고 공격 Trajectory 활용하는 것!
선배들과 나의 연구 차이점은? Compromise를 찾는 것이 main은 아님=>정원진 선배님
Compromise가 되었으면 Compromise가 된 노드에 대한 Trajectory도 활용함
그렇다면 그거에 대한 정보는 누가 파악하고 있는가?=>BS에서 정보를 얻는 방법=>일반적인 통신 체계를 통해서 내용을 받은 것임
=>정원진 선배님=>Trajectory로 활용할 수 있을만한 정보를 전달 한것임

키 복제에 관련된 부분을 SEF에서 확인해 보기!!

이웃노드를 활용하여 Compromise 노드에 대한 정보를 활용할 수도 있지 않을까?

Compromise가 공격을 하면서도 남들이 눈치를 채지 않고 공격이 성공할 수 있다는 말=>안정섭 선배님
노드에서 Compromise 행위를 하면서 정상적인 패턴으로 보낼 경우에는 탐지를 할 수 없는 것!!

Trajectory가 어떤 방법이다 라고 한정 짓는게 아니라 더 많은 정보를 가지고만 해결 할 수 있다고 가정하면, 
그 모든것을 Trajectory로 표현할 수 있는 것임
Trajectory로 표현할 수 없는 것이 있을까?=>감정 이런 부분은 할 수 없음 하지만 Trajectory로 표현할 필요가 없는 데이터임
객관화 할 수 있는 것에대한 제한을 받을 수 밖에 없음=>데이터화 할 수 있는 것, 정보화 할 수 있는 것들은 모두 Trajectory로
활용할 수 있음. 어떤 것인지 모를 때 분석이 되지 않았을 때는 표현이 불가능한거지, 그것이 아니라면 시공간에서 일어나는 모든
내용을 Trajectory로 계산해야될 내용이 표현됨!

필요한 내용만 Trajectory에 작성 하였을 뿐 필요하다면 더 많은 내용이 추가 되어도 된다!
state만 표현되어야 되는 것은 아님! state의 값을 정하는 것도 그 값만 있어도 문제를 풀 수 있기 때문에
그정도만 표현하는 것이고 문제를 풀 수 없다면 state를 더 많은 state로 쪼개는 것이 가능한 것임!

기존의 security protocol을 생각하지 않고 어디서 해도 상관이 없는 것
여기보다 더 많은 정보가 쌓이고, 어떤 식으로 찾아낼 수 있으면 상관이 없음
다음 노드에서 하기를 바라는 것은 아님 기존 방법으로는 그렇게 해도 힘드니깐.

diagram을 이용해서 공격이 발생한다면, 자체적으로 자멸하는 경우는 탐지할 수 없음
예를 들어서 센서 노드는 에너지가 제한적이기 때문에 무언가를 계속 해서 실행하면서 input, output 없이 계속 진행한다면
발견할 수 없을 것 같다.=>와야할 정보가 안온다거나, 하면 알 수 있을것 같음!!

Compromise 노드에서 공격을 하는데 시간정보를 누군가가 알 수있다는 가정에서 그러면 저렇게 다른 행위를 하면
다른 행위를 했다는 것은 시간 정보 이외에 의심할 수 있는 여지는 전혀 없는가? 꼭 다음 노드에서만 생각하지 말고 
판단하는 위치는 제한을 둘 필요가 없음. 시간 정보는 현재 잘 되어 있음 좀 더 확정적으로 하기 위해서 어디에선가는 내용을
보고 더 확증을 할 수가 있겠다에 대한 부분을 생각해 볼것!! CoS에서 Compromise가 일어난 경우 그 다음에 일어난 행위(공간적)으로)
이런 현상이 일어날수 있겠다 라는 것에 대한 생각을 해볼것!!

MAC생성이 발생하는 경우 연산이 실행되는 것=>이부분의 내용을 확인하면 찾을 수 있을 것 같다.
CoS에서 Compromise가 일어난 경우 그 다음에 Forwarding노드에서는 메시지가 drop되는 현상이 발생할 수 있음

입력값과 출력값이 다른 경우에도 공격이 발생했다고 알 수 있음=>이 부분에 대해서는 생각해 본적 없음 오오!!
=>그렇다면 시간정보가 필요한 건 아님, 근데 CoS에서 일어난다고 하면 찾을 수 없음=>BS에서 이런 처리를 할 수 있다는 것도
보조적으로 사용할 수 있다는 것, 하지만 CoS의 경우 입출력값이 다르기 때문에 찾을 수 없음

CoS에서도 공격을 하면서 안들키게 할 수 있을까?=>눈에 보이는 Trajectory를 가져올 수 있다는 가정인가?
시간이 늘어나는 경우가 공격만 있을까?=>MAC을 수집하는 동안에 중간에 보고서가 들어오거나 한다면 
즉, 한 이벤트에서는 CoS노드이면서 다른 이벤트에서는 Forwarding 노드인 경우
한 디바이스에서 여러개의 역할이 가능 할 수 있는 것!!=>그래서 여러가지 timing diagram을 두고 봐야하는 것임=> 좋은 예임
SCI로 하기 위해서는 정섭 선배가 얘기한 부분에 대해서 그것을 Trajectory로 표현하면 두가지가 나옴(한 diagram에 두가지를 사용할 수 이씅ㅁ)
나머지 두경우에 대해서도 생각해 본다면 SCI로 충분함.
원래 생각했던 CoS의 경우에 대해서 두가지 혹은 두가지 이상의 Trajectory를 놓고 할 수 있다면 구현할 필요는 없음
이런 식으로 적용을 하면 상당히 많은 것을 탐지할 수 있다. => 학문은 방법론이 중요한 것임
이런식의 방법을 다른 protocol에 적용하더라도 같은 방법으로  Compromise되는 것을 찾을 수 있음
문제 도출(Target)은 그렇게 정해 놓고 난해한문제를 해결했다 라는 것을 보여주고 말로 하면 됨!!

forwarding node에서 filtering 하고 나서 filtering했다는 내용을 BS에게 알리는가? No=>이부분에 대해서도 생각해 볼것!

그러면 얼마만큼 정보를 알았느냐 얼마만큼 수집을 전제로 하였는가 그것도 중요함! 공격을 했을 때 공격이라고 판단하기 위해서
Trajectory상에 나타난 정보를 있는 그대로(control center)에서 얼마만큼의 정보를 가지고 있어야 공격이라고 판단할 수 있느냐 그게
중요한 것임. 다 알아야 한다 혹은 얼마만큼 알아야 하는가 
CoS가 Forwading node로 쓰이는 경우=>CFFS
두가지 Trajectory를 다 활용해야함
이런 Trajectory가 없는 상태에서 있다면 그건 공격임!!
없는 상태에서 발생하면 공격이 있는것!!
있는 상태에서 발생하면 공격이 없는것!!

Compromise가 안된 것은 필요 이상의 정보가 있어도 됨!!
공격의 경우는 필요한 정보만 사용해야하는 이유는 많이 얻으려면 얻기가 힘듬!! Compromise 노드가 안주려고 할 것임
그래서 최소한의 정보만 사용해야 하는 것임!!
그러면 있는 정보를 모두 알 수 있다=>공격이 없는 경우에, 이런식으로 infra를 구축하면 얻을 수 있다 그건 reference가 있으므로
사용하면 됨!!다 얻을 수 있어야 한다. 다 얻을 수 있을까? 
제일 좋은 것은 모두 얻는 것
(시간적): 시점은 속일 수 없음
(공간적): 출력은 속일 수 있음, 입력은 속일 수 없음
세가지 모두가 있으면 탐지가 가능함 그런데 3개다 검사하려면 시간이 오래걸림
처리시간(시점)과 출력 S를 보면 그거에 대해서
처리시간 다르다면 입력과 출력을 확인하면 된다. 그렇다면 계산양이 확 줄게 됨, 
그리고 Forwarding 노드 diagram을 활용하면 더 많은 정보를 알 수 있음.=>CoS노드가 Forwarding
노드인 경우에 시간이 길어질 수 있기 때문에 공격인지 아닌지 판단이 정확히 알 수 없음

3개의 정보가 다 필요한 것은 맞고
3개의 정보 중 속일 수 있는게 있는가 (공격을 하고 나서 들키지 않을 수 있었는가) 출력 값의 경우
속일 수 있었음. 하나만 갖고는 속일 수 있지만, 3가지를 동시에 사용한다면 속일 수 없음.

Compromise 노드에서 일어나는 정보를 다 알 수 있다=>라는 가정을 하여도 됨!!(SCI논문 작성할 때)

다음에 해야할 것은 Temporal logic을 적용을 해서 이 Trajectory를 temporal logic으로
표현할 수 있으면 됨(rule)

Temporal logic은 rule+시간을 표현하고 있음
Temporal logic 책  + BM-Devs 논문 다시 읽어 보기
정상적인 절차에 대한 Trajectory(rule과 함께 연상)이 있어야 하고, 그래야 비정상을 아니깐, 그리고
공격에 해당하는 Trajectory가 있어야 하고, 그런걸 추려내야 함. =>정상 Trajectory와 다르면 비정상이니깐
추려 내면 됨. 추려낸 Trajectory 중에서 3가지 정보를 활용해서 확정 지으면 됨. 그런 정보는 BS에 가면
다 있음. 거기서 판단을 하면 됨, 더 빨리 판단할 수 있으면 좋고, 정상 Trajectory도 rule로 표현하고
공격 Trajectory도 rule로 표현하여 rule을 프로그램전에 다 설계를 해야함.
rule에 대한 pseudo code 작성해야함
결과는 좋은 논문에 내면 됨!!이게 결론!!

최근 10년 내에 lab에서 IEEE에 제출한 논문을 reference로 하면 됨!!

